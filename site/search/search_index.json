{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Thorlabs Controllers","text":"<p>The following documentation define the installation, setup, usage and error forum for the QuantumION Thorlabs Controllers</p>"},{"location":"#1-installation","title":"1.  Installation \ud83d\udd17","text":"<p>This section explains how to install the Thorlabs repository and setup an environment locally</p>"},{"location":"#2-thorlabs-cubes","title":"2.  Thorlabs Cubes \ud83d\udd17","text":"<p>This section explains how the Thorlabs controllers work, use cases, and code examples</p>"},{"location":"#3-tutorials","title":"3.  Tutorials \ud83d\udd17","text":"<p>This section outlines how to interact with the Thorlabs Cube controllers</p>"},{"location":"#repository-layout","title":"Repository Layout","text":"<pre><code>\ud83d\udcc1 .github/workflows/        # GitHub actions for CI/CD pipelines and automation\n\ud83d\udcc1 docs/                     # Documentation-related files, built with MkDocs\n\ud83d\udcc1 src/thorlabs_cube/\n   \ud83d\udcc1 driver/                   # Drivers for the supported Thorlabs products\n       \ud83d\udcc1 kcube/                    # Driver for Thorlabs K-Cube controllers\n       \ud83d\udcc1 tcube/                    # Driver for Thorlabs T-Cube controllers\n       \ud83d\udcc4 base.py                   # Base class for K-Cube and T-Cube drivers\n       \ud83d\udcc4 message.py                # Defines enumerated constants (hex) for communication\n   \ud83d\udcc4 aqctl_thorlabs_cube.py    # ARTIQ communication for controllers\n\ud83d\udcc1 test/                     # Test files and test case implementations\n\ud83d\udcc4 Dockerfile                # Docker container configuration\n\ud83d\udcc4 compose.yml               # Multi-container setup configuration\n\ud83d\udcc4 README.md                 # Project overview and guide\n\ud83d\udcc4 setup.py                  # Python package setup script\n\ud83d\udcc4 .pre-commit-config.yaml   # Pre-commit hooks for linting/formatting\n\ud83d\udcc4 .flake8                   # Linter configuration\n\ud83d\udcc4 .gitignore                # Git ignored files\n\ud83d\udcc4 .dockerignore             # Docker ignored files\n</code></pre>"},{"location":"sections/installation/","title":"Installation","text":""},{"location":"sections/installation/#step-1-clone-the-repository-then-install-using-pip","title":"Step 1: Clone the repository, then install using pip:","text":"<pre><code>$ git clone git@github.com:quantumion/thorlabs_cube.git\n$ cd thorlabs_cube\n</code></pre> <p>It is suggested to create python environment using venv for repository dependencies</p>"},{"location":"sections/installation/#step-2-create-a-python-virtual-environment","title":"Step 2: Create a Python virtual environment","text":"<pre><code>$ python3 -m venv venv\n$ source venv/bin/activate\n$ pip install .\n</code></pre> <ul> <li>venv is the standard naming convention for Python environments</li> <li>setup.py will be targetted for the installation of all repository dependencies</li> </ul>"},{"location":"sections/installation/#step-3-optionally-build-mkdocs-documentation","title":"Step 3: Optionally, build MkDocs documentation","text":"<pre><code>$ mkdocs serve\n</code></pre>"},{"location":"sections/cube/cube/","title":"Thorlabs Cube","text":"<p>Cubes are controllers made by Thorlabs that are used to control a variety of devices such as motors, piezo actuators, and other laboratory equipment. These controllers, including the K-Cube and T-Cube series, are commonly used in experimental setups for precise motion control and automation.</p>"},{"location":"sections/cube/cube/#t-cubes","title":"T-Cubes","text":"<ul> <li>TDC001: T-Cube DC Servo Motor Controller \ud83d\udd17</li> <li>TSC001: T-Cube Shutter Controller \ud83d\udd17</li> <li>TPZ001: T-Cube Piezo Controller \ud83d\udd17</li> <li>TPA101: T-Cube Position Sensing Detector Controller \ud83d\udd17</li> </ul>"},{"location":"sections/cube/cube/#k-cubes","title":"K-Cubes","text":"<ul> <li>KDC101: K-Cube DC Servo Motor Controller \ud83d\udd17</li> <li>KSC101: K-Cube Solenoid Controller \ud83d\udd17</li> <li>KPZ101: K-Cube Piezo Controller \ud83d\udd17</li> <li>KPA101: K-Cube PSD Auto Aligner Controller \ud83d\udd17</li> </ul>"},{"location":"sections/cube/kcube/kdc101/","title":"KDC101","text":""},{"location":"sections/cube/kcube/kdc101/#controller-description","title":"Controller Description","text":"<p>The KDC101 is a compact single-channel K-Cube controller from Thorlabs designed for precise control of DC motors. It is optimized for positioning applications requiring accurate and smooth motion control. The KDC101 supports bidirectional DC motor control with adjustable speed, acceleration, and position settings. It features USB connectivity for computer control via Thorlabs\u2019 Kinesis Software or QuantumION's Thorlabs Cube Repository.</p>"},{"location":"sections/cube/kcube/kdc101/#controller-use-cases","title":"Controller Use-Cases","text":"<ul> <li>KDC101 is used in applications requiring fine motorized adjustments, such as:<ol> <li>Optical Alignment: Precise positioning of lenses, mirrors, and other optical components.</li> <li>Microscopy: Fine control of motorized stages for specimen alignment or focusing.</li> <li>Laser Systems: Stabilizing or adjusting optical components in beam paths.</li> </ol> </li> </ul>"},{"location":"sections/cube/kcube/kdc101/#peripherals-examples","title":"Peripherals Examples","text":"<ul> <li>DC Motor Actuators </li> <li>Motorized Mirror Mounts </li> <li>Motorized Stages </li> </ul>"},{"location":"sections/cube/kcube/kdc101/#api-reference","title":"API Reference","text":"<p>               Bases: <code>Tdc</code></p> <p>KDC101 K-Cube Brushed DC Servo Motor Controller class</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kdc.py</code> <pre><code>class Kdc(Tdc):\n    \"\"\"\n    KDC101 K-Cube Brushed DC Servo Motor Controller class\n    \"\"\"\n\n    async def handle_message(self, msg: Message) -&gt; None:\n        \"\"\"Parse messages from the device.\n        Minor adaptation from TDC001 method.\"\"\"\n        msg_id = msg.id\n        data = msg.data\n\n        if msg_id == MGMSG.HW_DISCONNECT:\n            raise MsgError(\"Error: Please disconnect the KDC101\")\n        elif msg_id == MGMSG.HW_RESPONSE:\n            raise MsgError(\"Hardware error, please disconnect and reconnect the KDC101\")\n        elif msg_id == MGMSG.HW_RICHRESPONSE:\n            (code,) = st.unpack(\"&lt;H\", data[2:4])\n            raise MsgError(\n                f\"Hardware error {code}: {data[4:].decode(encoding='ascii')}\"\n            )\n        elif msg_id in [\n            MGMSG.MOT_MOVE_COMPLETED,\n            MGMSG.MOT_MOVE_STOPPED,\n            MGMSG.MOT_GET_DCSTATUSUPDATE,\n        ]:\n            if self.status_report_counter == 25:\n                self.status_report_counter = 0\n                await self.send(Message(MGMSG.MOT_ACK_DCSTATUSUPDATE))\n            else:\n                self.status_report_counter += 1\n            # 'r' is a currently unused and reserved field\n            self.position, self.velocity, r, self.status = st.unpack(\"&lt;LHHL\", data[2:])\n\n    async def set_digital_outputs_config(self):\n        \"\"\"Set digital output pins on the motor control output port.\n\n        Not required for the KDC101. Unimplemented.\n        \"\"\"\n        raise NotImplementedError\n\n    async def get_digital_outputs_config(self):\n        \"\"\"Get digital output pin values on the motor control output port.\n\n        Not required for the KDC101. Unimplemented.\n        \"\"\"\n        raise NotImplementedError\n\n    async def set_mmi_parameters(\n        self,\n        mode: int,\n        max_velocity: int,\n        max_acceleration: int,\n        direction: int,\n        position1: int,\n        position2: int,\n        brightness: int,\n        timeout: int,\n        dim: int,\n    ) -&gt; None:\n        \"\"\"Set the operating parameters of the top panel wheel (Joystick).\n\n        :param mode: This parameter specifies the operating mode of the\n                     wheel/joy stick as follows:\\n\n                     * 1: Velocity Control Mode - Deflecting the wheel starts\n                          a move with the velocity proportional to\n                          the deflection. The maximum velocity (i.e. velocity\n                          corresponding to the full deflection of the\n                          joystick wheel) and acceleration are specified in the\n                          max_velocity and max_acceleration parameters.\n                     * 2: Jog Mode - Deflecting the wheel initiates a jog move,\n                          using the parameters specified by the set_jog\n                          step_size and max_velocity methods. Keeping the wheel\n                          deflected repeats the move automatically after the\n                          current move has completed.\n                     * 3: Go To Position Mode - Deflecting the wheel starts a\n                          move from the current position to one of the two\n                          predefined \u201cteach\u201d positions. The teach positions are\n                          specified in number of steps from the home position\n                          in the position1 and position parameters.\n        :param max_velocity: The maximum velocity of a move initiated by the\n                             top panel velocity wheel.\n        :param max_acceleration: The maximum acceleration of a move initiated\n                                 by the top panel velocity wheel.\n        :param direction: This parameter specifies the direction of a move\n                          initiated by the velocity wheel as follows:\\n\n                          * 0: Wheel initiated moves are disabled. Wheel used\n                               for menuing only.\n                          * 1: Upwards rotation of the wheel results in a\n                               positive motion (i.e. increased position count).\n                               The following option applies only when the mode\n                               is set to Velocity Control Mode (1). If set to\n                               Jog Mode (2) or Go to Position Mode (3),\n                               the following option is ignored.\\n\n                          * 2: Upwards rotation of the wheel results in a\n                               negative motion (i.e. decreased position count).\n        :param position1: The preset position 1 when operating in go to\n                          position mode, measured in position steps from\n                          the home position.\n        :param position2: The preset position 2 when operating in go to\n                          position mode, measured in position steps from\n                          the home position.\n        :param brightness: In certain applications, it may be necessary to\n                           adjust the brightness of the LED display on\n                           the top of the unit. The brightness is set as a\n                           value from 0 (Off) to 100 (brightest). The\n                           display can be turned off completely by entering a\n                           setting of zero, however, pressing the\n                           MENU button on the top panel will temporarily\n                           illuminate the display at its lowest brightness\n                           setting to allow adjustments. When the display\n                           returns to its default position display mode,\n                           it will turn off again.\n        :param timeout: 'Burn In' of the display can occur if it remains\n                        static for a long time. To prevent this, the\n                        display is automatically dimmed after the time\n                        interval specified in the timeout parameter has\n                        elapsed. Set in minutes in the range 0 (never dimmed)\n                        to 480. The dim level is set in the\n                        dim parameter below.\n        :param dim: The dim level, as a value from 0 (Off) to 10 (brightest)\n                    but is also limited by the brightness parameter.\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HHllHllHHHlHH\",\n            Kdc._CHANNEL,\n            mode,\n            max_velocity,\n            max_acceleration,\n            direction,\n            position1,\n            position2,\n            brightness,\n            timeout,\n            dim,\n            Kdc._RESERVED,\n            Kdc._RESERVED,\n            Kdc._RESERVED,\n        )\n        await self.send(Message(MGMSG.MOT_SET_KCUBEMMIPARAMS, data=payload))\n\n    async def get_mmi_parameters(\n        self,\n    ) -&gt; tuple[int, int, int, int, int, int, int, int, int]:\n        \"\"\"Get the operating parameters of the top panel wheel (Joystick).\n\n        :return: A 9 int tuple containing in this order: joystick mode,\n                 maximum velocity, maximum acceleration, direction, position1,\n                 position2, brightness, timeout, and dim. Cf.\n                 :py:meth:`set_mmi_parameters() &lt;Kdc.set_mmi_parameters&gt;`\n                 for description.\n        :rtype: A 9 int tuple\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_KCUBEMMIPARAMS,\n            [MGMSG.MOT_GET_KCUBEMMIPARAMS],\n            Kdc._REQUEST_LENGTH,\n        )\n        return st.unpack(\"&lt;HllHllHHH\", get_msg.data[2:28])\n\n    async def set_trigger_io_config(\n        self, mode1: int, polarity1: int, mode2: int, polarity2: int\n    ) -&gt; None:\n        \"\"\"Set trigger intput/output parameters.\n\n        The K-Cube motor controllers have two bidirectional trigger ports\n        (TRIG1 and TRIG2) that can be used to read an external logic signal or\n        output a logic level to control external equipment. Either of them can\n        be independently configured as an input or an output and the active\n        logic state can be selected High or Low to suit the requirements of the\n        application. Electrically the ports output 5 Volt logic signals and are\n        designed to be driven from a 5 Volt logic. When the port is used in the\n        input mode, the logic levels are TTL compatible, i.e. a voltage level\n        less than 0.8 Volt will be recognised as a logic LOW and a level\n        greater than 2.4 Volt as a logic HIGH. The input contains a weak\n        pull-up, so the state of the input with nothing connected will default\n        to a logic HIGH. The weak pull-up feature allows a passive device, such\n        as a mechanical switch to be connected directly to the input. When the\n        port is used as an output it provides a push-pull drive of 5 Volts,\n        with the maximum current limited to approximately 8 mA. The current\n        limit prevents damage when the output is accidentally shorted to ground\n        or driven to the opposite logic state by external circuity.\n\n        **Warning**: do not drive the TRIG ports from any voltage source that\n        can produce an output in excess of the normal 0 to 5 Volt logic level\n        range. In any case the voltage at the TRIG ports must be limited to\n        -0.25 to +5.25 Volts.\n\n        **Input Trigger Modes**\\n\n        When configured as an input, the TRIG ports can be used as a general\n        purpose digital input, or for triggering a relative, absolute or home\n        move as follows:\n\n        * 0x00: The trigger IO is disabled\n        * 0x01: General purpose logic input (read through status bits using the\n          :py:meth:`get_status_bits()\n          &lt;thorlabs_cube.driver.tcube.tdc.Tdc.get_status_bits&gt;` method)\n        * 0x02: Input trigger for relative move\n        * 0x03: Input trigger for absolute move\n        * 0x04: Input trigger for home move\n\n        When used for triggering a move, the port is edge sensitive. In other\n        words, it has to see a transition from the inactive to the active logic\n        state (Low-&gt;High or High-&gt;Low) for the trigger input to be recognized.\n        For the same reason a sustained logic level will not trigger repeated\n        moves. The trigger input has to return to its inactive state first in\n        order to start the next trigger.\n\n        **Output Trigger Modes**\\n\n        When configured as an output, the TRIG ports can be used as a general\n        purpose digital output, or to indicate motion status or to produce a\n        trigger pulse at configurable positions as follows:\n\n        * 0x0A: General purpose logic output (set using the\n                :py:meth:`set_digital_outputs_config()\n                &lt;Kdc.set_digital_outputs_config&gt;` method).\n        * 0x0B: Trigger output active (level) when motor 'in motion'. The\n                output trigger goes high (5V) or low (0V) (as set in the\n                polarity1 and polarity2 parameters) when the stage is\n                in motion.\n        * 0x0C: Trigger output active (level) when motor at 'maximum velocity'.\n        * 0x0D: Trigger output active (pulsed) at pre-defined positions moving\n                forward (set using start_position_fwd,\n                interval_fwd, num_pulses_fwd and pulse_width parameters in the\n                :py:meth:`set_position_trigger_parameters()\n                &lt;Kdc.set_position_trigger_parameters&gt;` message). Only one\n                Trigger port at a time can be set to this mode.\n        * 0x0E: Trigger output active (pulsed) at pre-defined positions moving\n                backwards (set using start_position_rev, interval_rev,\n                num_pulses_rev and pulse_width parameters in the\n                :py:meth:`set_position_trigger_parameters()\n                &lt;Kdc.set_position_trigger_parameters&gt;` message). Only one\n                Trigger port at a time can be set to this mode.\n        * 0x0F: Trigger output active (pulsed) at pre-defined positions moving\n                forwards and backward. Only one Trigger port at a time can be\n                set to this mode.\n\n        :param mode1: TRIG1 operating mode\n        :param polarity1: The active state of TRIG1 (i.e. logic high or\n                          logic low)\n        :param mode2: TRIG2 operating mode\n        :param polarity2: The active state of TRIG2 (i.e. logic high or\n                          logic low)\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HHHHHQH\",\n            Kdc._CHANNEL,\n            mode1,\n            polarity1,\n            mode2,\n            polarity2,\n            Kdc._RESERVED,\n            Kdc._RESERVED,\n        )\n        await self.send(Message(MGMSG.MOT_SET_KCUBETRIGIOCONFIG, data=payload))\n\n    async def get_trigger_io_config(self) -&gt; tuple[int, int, int, int]:\n        \"\"\"Get trigger input/output parameters.\n\n        :return: A 4 int tuple containing in this order: mode1, polarity1,\n                 mode2, polarity2. Cf.\n                 :py:meth:`get_trigger_io_config()&lt;Kdc.get_trigger_io_config&gt;`\n                 for description.\n        :rtype: A 4 int tuple\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_KCUBETRIGIOCONFIG,\n            [MGMSG.MOT_GET_KCUBETRIGIOCONFIG],\n            Kdc._REQUEST_LENGTH,\n        )\n        return st.unpack(\"&lt;HHHH\", get_msg.data[2:10])\n\n    async def set_position_trigger_parameters(\n        self,\n        start_position_fwd: int,\n        interval_fwd: int,\n        num_pulses_fwd: int,\n        start_position_rev: int,\n        interval_rev: int,\n        num_pulses_rev: int,\n        pulse_width: int,\n        num_cycles: int,\n    ) -&gt; None:\n        \"\"\"Set positioning trigger parameters.\n\n        The K-Cube motor controllers have two bidirectional trigger ports\n        (TRIG1 and TRIG2) that can be set to be used as input or output\n        triggers. This method sets operating parameters used when the\n        triggering mode is set to a trigger out position steps mode by calling\n        the ;py:meth:`set_trigger_io_config()&lt;Kdc.set_trigger_io_config&gt;`\n        method. As soon as position triggering is selected on either of the\n        TRIG ports, the port will assert the inactive logic state. As the stage\n        moves in its travel range and the actual position matches the position\n        set in the start_position_fwd parameter, the TRIG port will output its\n        active logic state. The active state will be output for the length of\n        time specified by the pulse_width parameter, then return to its\n        inactive state and schedule the next position trigger point at the\n        start_position_fwd value plus the value set in the interval_fwd\n        parameter. Thus when this second position is reached, the TRIG output\n        will be asserted to its active state again. The sequence is repeated\n        the number of times set in the num_pulses_fwd parameter. When the\n        number of pulses set in the num_pulses_fwd parameter has been\n        generated, the trigger engine will schedule the next position to occur\n        at the position specified in the start_position_rev parameter. The same\n        sequence as the forward direction is now repeated in reverse, except\n        that the interval_rev and num_pulses_rev parameters apply. When the\n        number of pulses has been output, the entire forward-reverse sequence\n        will repeat the number of times specified by num_cycles parameter. This\n        means that the total number of pulses output will be num_cycles x\n        (num_pulses_fwd + num_pulses_rev).\n\n        Once the total number of output pulses have been generated, the trigger\n        output will remain inactive.\n\n        When a unidirectional sequence is selected, only the forward or reverse\n        part of the sequence will be activated.\n\n        :param start_position_fwd: When moving forward, this is the stage\n                                   position [in position counts - encoder\n                                   counts or microsteps] to start the\n                                   triggering sequence.\n        :param interval_fwd: When moving forward, this is the interval\n                             [in position counts - encoder counts or\n                             microsteps] at which to output the trigger pulses.\n        :param num_pulses_fwd: Number of output pulses during a forward move.\n        :param start_position_rev: When moving backwards, this is the stage\n                                   position [in position counts - encoder\n                                   counts or microsteps] to start the\n                                   triggering sequence.\n        :param interval_rev: When moving backwards, this is the interval [in\n                             position counts - encoder counts or microsteps] at\n                             which to output the trigger pulses.\n        :param num_pulses_rev: Number of output pulses during a backwards move.\n        :param pulse_width: Trigger output pulse width\n                            (from 1 \u00b5s to 1000000 \u00b5s).\n        :param num_cycles: Number of forward/reverse move cycles.\n        \"\"\"\n        payload = st.pack(\n            \"&lt;Hllllllll\",\n            Kdc._CHANNEL,\n            start_position_fwd,\n            interval_fwd,\n            num_pulses_fwd,\n            start_position_rev,\n            interval_rev,\n            num_pulses_rev,\n            pulse_width,\n            num_cycles,\n        )\n        await self.send(\n            Message(\n                MGMSG.MOT_SET_KCUBEPOSTRIGPARAMS,\n                data=payload,\n            )\n        )\n\n    async def get_position_trigger_parameters(\n        self,\n    ) -&gt; tuple[int, int, int, int, int, int, int, int]:\n        \"\"\"Get the positioning trigger parameters.\n\n        :return: An 8 int tuple containing in this order: start_position_fwd,\n                 interval_fwd, num_pulses_fwd, start_position_rev,\n                 interval_rev, num_pulses_rev, pulse_width, num_cycles. Cf.\n                 :py:meth:`set_position_trigger_parameters()\n                 &lt;Kdc.set_position_trigger_parameters&gt;` for description.\n        :rtype: An 8 int tuple\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_KCUBEPOSTRIGPARAMS,\n            [MGMSG.MOT_GET_KCUBEPOSTRIGPARAMS],\n            Kdc._REQUEST_LENGTH,\n        )\n        return st.unpack(\"&lt;llllllll\", get_msg.data[2:34])\n</code></pre>"},{"location":"sections/cube/kcube/kdc101/#thorlabs_cube.driver.kcube.kdc.Kdc.get_digital_outputs_config","title":"<code>get_digital_outputs_config()</code>  <code>async</code>","text":"<p>Get digital output pin values on the motor control output port.</p> <p>Not required for the KDC101. Unimplemented.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kdc.py</code> <pre><code>async def get_digital_outputs_config(self):\n    \"\"\"Get digital output pin values on the motor control output port.\n\n    Not required for the KDC101. Unimplemented.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"sections/cube/kcube/kdc101/#thorlabs_cube.driver.kcube.kdc.Kdc.get_mmi_parameters","title":"<code>get_mmi_parameters()</code>  <code>async</code>","text":"<p>Get the operating parameters of the top panel wheel (Joystick).</p> <p>:return: A 9 int tuple containing in this order: joystick mode,          maximum velocity, maximum acceleration, direction, position1,          position2, brightness, timeout, and dim. Cf.          :py:meth:<code>set_mmi_parameters() &lt;Kdc.set_mmi_parameters&gt;</code>          for description. :rtype: A 9 int tuple</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kdc.py</code> <pre><code>async def get_mmi_parameters(\n    self,\n) -&gt; tuple[int, int, int, int, int, int, int, int, int]:\n    \"\"\"Get the operating parameters of the top panel wheel (Joystick).\n\n    :return: A 9 int tuple containing in this order: joystick mode,\n             maximum velocity, maximum acceleration, direction, position1,\n             position2, brightness, timeout, and dim. Cf.\n             :py:meth:`set_mmi_parameters() &lt;Kdc.set_mmi_parameters&gt;`\n             for description.\n    :rtype: A 9 int tuple\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_KCUBEMMIPARAMS,\n        [MGMSG.MOT_GET_KCUBEMMIPARAMS],\n        Kdc._REQUEST_LENGTH,\n    )\n    return st.unpack(\"&lt;HllHllHHH\", get_msg.data[2:28])\n</code></pre>"},{"location":"sections/cube/kcube/kdc101/#thorlabs_cube.driver.kcube.kdc.Kdc.get_position_trigger_parameters","title":"<code>get_position_trigger_parameters()</code>  <code>async</code>","text":"<p>Get the positioning trigger parameters.</p> <p>:return: An 8 int tuple containing in this order: start_position_fwd,          interval_fwd, num_pulses_fwd, start_position_rev,          interval_rev, num_pulses_rev, pulse_width, num_cycles. Cf.          :py:meth:<code>set_position_trigger_parameters()          &lt;Kdc.set_position_trigger_parameters&gt;</code> for description. :rtype: An 8 int tuple</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kdc.py</code> <pre><code>async def get_position_trigger_parameters(\n    self,\n) -&gt; tuple[int, int, int, int, int, int, int, int]:\n    \"\"\"Get the positioning trigger parameters.\n\n    :return: An 8 int tuple containing in this order: start_position_fwd,\n             interval_fwd, num_pulses_fwd, start_position_rev,\n             interval_rev, num_pulses_rev, pulse_width, num_cycles. Cf.\n             :py:meth:`set_position_trigger_parameters()\n             &lt;Kdc.set_position_trigger_parameters&gt;` for description.\n    :rtype: An 8 int tuple\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_KCUBEPOSTRIGPARAMS,\n        [MGMSG.MOT_GET_KCUBEPOSTRIGPARAMS],\n        Kdc._REQUEST_LENGTH,\n    )\n    return st.unpack(\"&lt;llllllll\", get_msg.data[2:34])\n</code></pre>"},{"location":"sections/cube/kcube/kdc101/#thorlabs_cube.driver.kcube.kdc.Kdc.get_trigger_io_config","title":"<code>get_trigger_io_config()</code>  <code>async</code>","text":"<p>Get trigger input/output parameters.</p> <p>:return: A 4 int tuple containing in this order: mode1, polarity1,          mode2, polarity2. Cf.          :py:meth:<code>get_trigger_io_config()&lt;Kdc.get_trigger_io_config&gt;</code>          for description. :rtype: A 4 int tuple</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kdc.py</code> <pre><code>async def get_trigger_io_config(self) -&gt; tuple[int, int, int, int]:\n    \"\"\"Get trigger input/output parameters.\n\n    :return: A 4 int tuple containing in this order: mode1, polarity1,\n             mode2, polarity2. Cf.\n             :py:meth:`get_trigger_io_config()&lt;Kdc.get_trigger_io_config&gt;`\n             for description.\n    :rtype: A 4 int tuple\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_KCUBETRIGIOCONFIG,\n        [MGMSG.MOT_GET_KCUBETRIGIOCONFIG],\n        Kdc._REQUEST_LENGTH,\n    )\n    return st.unpack(\"&lt;HHHH\", get_msg.data[2:10])\n</code></pre>"},{"location":"sections/cube/kcube/kdc101/#thorlabs_cube.driver.kcube.kdc.Kdc.handle_message","title":"<code>handle_message(msg)</code>  <code>async</code>","text":"<p>Parse messages from the device. Minor adaptation from TDC001 method.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kdc.py</code> <pre><code>async def handle_message(self, msg: Message) -&gt; None:\n    \"\"\"Parse messages from the device.\n    Minor adaptation from TDC001 method.\"\"\"\n    msg_id = msg.id\n    data = msg.data\n\n    if msg_id == MGMSG.HW_DISCONNECT:\n        raise MsgError(\"Error: Please disconnect the KDC101\")\n    elif msg_id == MGMSG.HW_RESPONSE:\n        raise MsgError(\"Hardware error, please disconnect and reconnect the KDC101\")\n    elif msg_id == MGMSG.HW_RICHRESPONSE:\n        (code,) = st.unpack(\"&lt;H\", data[2:4])\n        raise MsgError(\n            f\"Hardware error {code}: {data[4:].decode(encoding='ascii')}\"\n        )\n    elif msg_id in [\n        MGMSG.MOT_MOVE_COMPLETED,\n        MGMSG.MOT_MOVE_STOPPED,\n        MGMSG.MOT_GET_DCSTATUSUPDATE,\n    ]:\n        if self.status_report_counter == 25:\n            self.status_report_counter = 0\n            await self.send(Message(MGMSG.MOT_ACK_DCSTATUSUPDATE))\n        else:\n            self.status_report_counter += 1\n        # 'r' is a currently unused and reserved field\n        self.position, self.velocity, r, self.status = st.unpack(\"&lt;LHHL\", data[2:])\n</code></pre>"},{"location":"sections/cube/kcube/kdc101/#thorlabs_cube.driver.kcube.kdc.Kdc.set_digital_outputs_config","title":"<code>set_digital_outputs_config()</code>  <code>async</code>","text":"<p>Set digital output pins on the motor control output port.</p> <p>Not required for the KDC101. Unimplemented.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kdc.py</code> <pre><code>async def set_digital_outputs_config(self):\n    \"\"\"Set digital output pins on the motor control output port.\n\n    Not required for the KDC101. Unimplemented.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"sections/cube/kcube/kdc101/#thorlabs_cube.driver.kcube.kdc.Kdc.set_mmi_parameters","title":"<code>set_mmi_parameters(mode, max_velocity, max_acceleration, direction, position1, position2, brightness, timeout, dim)</code>  <code>async</code>","text":"<p>Set the operating parameters of the top panel wheel (Joystick).</p> <p>:param mode: This parameter specifies the operating mode of the              wheel/joy stick as follows:</p> <pre><code>         * 1: Velocity Control Mode - Deflecting the wheel starts\n              a move with the velocity proportional to\n              the deflection. The maximum velocity (i.e. velocity\n              corresponding to the full deflection of the\n              joystick wheel) and acceleration are specified in the\n              max_velocity and max_acceleration parameters.\n         * 2: Jog Mode - Deflecting the wheel initiates a jog move,\n              using the parameters specified by the set_jog\n              step_size and max_velocity methods. Keeping the wheel\n              deflected repeats the move automatically after the\n              current move has completed.\n         * 3: Go To Position Mode - Deflecting the wheel starts a\n              move from the current position to one of the two\n              predefined \u201cteach\u201d positions. The teach positions are\n              specified in number of steps from the home position\n              in the position1 and position parameters.\n</code></pre> <p>:param max_velocity: The maximum velocity of a move initiated by the                      top panel velocity wheel. :param max_acceleration: The maximum acceleration of a move initiated                          by the top panel velocity wheel. :param direction: This parameter specifies the direction of a move                   initiated by the velocity wheel as follows:</p> <pre><code>              * 0: Wheel initiated moves are disabled. Wheel used\n                   for menuing only.\n              * 1: Upwards rotation of the wheel results in a\n                   positive motion (i.e. increased position count).\n                   The following option applies only when the mode\n                   is set to Velocity Control Mode (1). If set to\n                   Jog Mode (2) or Go to Position Mode (3),\n                   the following option is ignored.\n\n              * 2: Upwards rotation of the wheel results in a\n                   negative motion (i.e. decreased position count).\n</code></pre> <p>:param position1: The preset position 1 when operating in go to                   position mode, measured in position steps from                   the home position. :param position2: The preset position 2 when operating in go to                   position mode, measured in position steps from                   the home position. :param brightness: In certain applications, it may be necessary to                    adjust the brightness of the LED display on                    the top of the unit. The brightness is set as a                    value from 0 (Off) to 100 (brightest). The                    display can be turned off completely by entering a                    setting of zero, however, pressing the                    MENU button on the top panel will temporarily                    illuminate the display at its lowest brightness                    setting to allow adjustments. When the display                    returns to its default position display mode,                    it will turn off again. :param timeout: 'Burn In' of the display can occur if it remains                 static for a long time. To prevent this, the                 display is automatically dimmed after the time                 interval specified in the timeout parameter has                 elapsed. Set in minutes in the range 0 (never dimmed)                 to 480. The dim level is set in the                 dim parameter below. :param dim: The dim level, as a value from 0 (Off) to 10 (brightest)             but is also limited by the brightness parameter.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kdc.py</code> <pre><code>async def set_mmi_parameters(\n    self,\n    mode: int,\n    max_velocity: int,\n    max_acceleration: int,\n    direction: int,\n    position1: int,\n    position2: int,\n    brightness: int,\n    timeout: int,\n    dim: int,\n) -&gt; None:\n    \"\"\"Set the operating parameters of the top panel wheel (Joystick).\n\n    :param mode: This parameter specifies the operating mode of the\n                 wheel/joy stick as follows:\\n\n                 * 1: Velocity Control Mode - Deflecting the wheel starts\n                      a move with the velocity proportional to\n                      the deflection. The maximum velocity (i.e. velocity\n                      corresponding to the full deflection of the\n                      joystick wheel) and acceleration are specified in the\n                      max_velocity and max_acceleration parameters.\n                 * 2: Jog Mode - Deflecting the wheel initiates a jog move,\n                      using the parameters specified by the set_jog\n                      step_size and max_velocity methods. Keeping the wheel\n                      deflected repeats the move automatically after the\n                      current move has completed.\n                 * 3: Go To Position Mode - Deflecting the wheel starts a\n                      move from the current position to one of the two\n                      predefined \u201cteach\u201d positions. The teach positions are\n                      specified in number of steps from the home position\n                      in the position1 and position parameters.\n    :param max_velocity: The maximum velocity of a move initiated by the\n                         top panel velocity wheel.\n    :param max_acceleration: The maximum acceleration of a move initiated\n                             by the top panel velocity wheel.\n    :param direction: This parameter specifies the direction of a move\n                      initiated by the velocity wheel as follows:\\n\n                      * 0: Wheel initiated moves are disabled. Wheel used\n                           for menuing only.\n                      * 1: Upwards rotation of the wheel results in a\n                           positive motion (i.e. increased position count).\n                           The following option applies only when the mode\n                           is set to Velocity Control Mode (1). If set to\n                           Jog Mode (2) or Go to Position Mode (3),\n                           the following option is ignored.\\n\n                      * 2: Upwards rotation of the wheel results in a\n                           negative motion (i.e. decreased position count).\n    :param position1: The preset position 1 when operating in go to\n                      position mode, measured in position steps from\n                      the home position.\n    :param position2: The preset position 2 when operating in go to\n                      position mode, measured in position steps from\n                      the home position.\n    :param brightness: In certain applications, it may be necessary to\n                       adjust the brightness of the LED display on\n                       the top of the unit. The brightness is set as a\n                       value from 0 (Off) to 100 (brightest). The\n                       display can be turned off completely by entering a\n                       setting of zero, however, pressing the\n                       MENU button on the top panel will temporarily\n                       illuminate the display at its lowest brightness\n                       setting to allow adjustments. When the display\n                       returns to its default position display mode,\n                       it will turn off again.\n    :param timeout: 'Burn In' of the display can occur if it remains\n                    static for a long time. To prevent this, the\n                    display is automatically dimmed after the time\n                    interval specified in the timeout parameter has\n                    elapsed. Set in minutes in the range 0 (never dimmed)\n                    to 480. The dim level is set in the\n                    dim parameter below.\n    :param dim: The dim level, as a value from 0 (Off) to 10 (brightest)\n                but is also limited by the brightness parameter.\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HHllHllHHHlHH\",\n        Kdc._CHANNEL,\n        mode,\n        max_velocity,\n        max_acceleration,\n        direction,\n        position1,\n        position2,\n        brightness,\n        timeout,\n        dim,\n        Kdc._RESERVED,\n        Kdc._RESERVED,\n        Kdc._RESERVED,\n    )\n    await self.send(Message(MGMSG.MOT_SET_KCUBEMMIPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/kcube/kdc101/#thorlabs_cube.driver.kcube.kdc.Kdc.set_position_trigger_parameters","title":"<code>set_position_trigger_parameters(start_position_fwd, interval_fwd, num_pulses_fwd, start_position_rev, interval_rev, num_pulses_rev, pulse_width, num_cycles)</code>  <code>async</code>","text":"<p>Set positioning trigger parameters.</p> <p>The K-Cube motor controllers have two bidirectional trigger ports (TRIG1 and TRIG2) that can be set to be used as input or output triggers. This method sets operating parameters used when the triggering mode is set to a trigger out position steps mode by calling the ;py:meth:<code>set_trigger_io_config()&lt;Kdc.set_trigger_io_config&gt;</code> method. As soon as position triggering is selected on either of the TRIG ports, the port will assert the inactive logic state. As the stage moves in its travel range and the actual position matches the position set in the start_position_fwd parameter, the TRIG port will output its active logic state. The active state will be output for the length of time specified by the pulse_width parameter, then return to its inactive state and schedule the next position trigger point at the start_position_fwd value plus the value set in the interval_fwd parameter. Thus when this second position is reached, the TRIG output will be asserted to its active state again. The sequence is repeated the number of times set in the num_pulses_fwd parameter. When the number of pulses set in the num_pulses_fwd parameter has been generated, the trigger engine will schedule the next position to occur at the position specified in the start_position_rev parameter. The same sequence as the forward direction is now repeated in reverse, except that the interval_rev and num_pulses_rev parameters apply. When the number of pulses has been output, the entire forward-reverse sequence will repeat the number of times specified by num_cycles parameter. This means that the total number of pulses output will be num_cycles x (num_pulses_fwd + num_pulses_rev).</p> <p>Once the total number of output pulses have been generated, the trigger output will remain inactive.</p> <p>When a unidirectional sequence is selected, only the forward or reverse part of the sequence will be activated.</p> <p>:param start_position_fwd: When moving forward, this is the stage                            position [in position counts - encoder                            counts or microsteps] to start the                            triggering sequence. :param interval_fwd: When moving forward, this is the interval                      [in position counts - encoder counts or                      microsteps] at which to output the trigger pulses. :param num_pulses_fwd: Number of output pulses during a forward move. :param start_position_rev: When moving backwards, this is the stage                            position [in position counts - encoder                            counts or microsteps] to start the                            triggering sequence. :param interval_rev: When moving backwards, this is the interval [in                      position counts - encoder counts or microsteps] at                      which to output the trigger pulses. :param num_pulses_rev: Number of output pulses during a backwards move. :param pulse_width: Trigger output pulse width                     (from 1 \u00b5s to 1000000 \u00b5s). :param num_cycles: Number of forward/reverse move cycles.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kdc.py</code> <pre><code>async def set_position_trigger_parameters(\n    self,\n    start_position_fwd: int,\n    interval_fwd: int,\n    num_pulses_fwd: int,\n    start_position_rev: int,\n    interval_rev: int,\n    num_pulses_rev: int,\n    pulse_width: int,\n    num_cycles: int,\n) -&gt; None:\n    \"\"\"Set positioning trigger parameters.\n\n    The K-Cube motor controllers have two bidirectional trigger ports\n    (TRIG1 and TRIG2) that can be set to be used as input or output\n    triggers. This method sets operating parameters used when the\n    triggering mode is set to a trigger out position steps mode by calling\n    the ;py:meth:`set_trigger_io_config()&lt;Kdc.set_trigger_io_config&gt;`\n    method. As soon as position triggering is selected on either of the\n    TRIG ports, the port will assert the inactive logic state. As the stage\n    moves in its travel range and the actual position matches the position\n    set in the start_position_fwd parameter, the TRIG port will output its\n    active logic state. The active state will be output for the length of\n    time specified by the pulse_width parameter, then return to its\n    inactive state and schedule the next position trigger point at the\n    start_position_fwd value plus the value set in the interval_fwd\n    parameter. Thus when this second position is reached, the TRIG output\n    will be asserted to its active state again. The sequence is repeated\n    the number of times set in the num_pulses_fwd parameter. When the\n    number of pulses set in the num_pulses_fwd parameter has been\n    generated, the trigger engine will schedule the next position to occur\n    at the position specified in the start_position_rev parameter. The same\n    sequence as the forward direction is now repeated in reverse, except\n    that the interval_rev and num_pulses_rev parameters apply. When the\n    number of pulses has been output, the entire forward-reverse sequence\n    will repeat the number of times specified by num_cycles parameter. This\n    means that the total number of pulses output will be num_cycles x\n    (num_pulses_fwd + num_pulses_rev).\n\n    Once the total number of output pulses have been generated, the trigger\n    output will remain inactive.\n\n    When a unidirectional sequence is selected, only the forward or reverse\n    part of the sequence will be activated.\n\n    :param start_position_fwd: When moving forward, this is the stage\n                               position [in position counts - encoder\n                               counts or microsteps] to start the\n                               triggering sequence.\n    :param interval_fwd: When moving forward, this is the interval\n                         [in position counts - encoder counts or\n                         microsteps] at which to output the trigger pulses.\n    :param num_pulses_fwd: Number of output pulses during a forward move.\n    :param start_position_rev: When moving backwards, this is the stage\n                               position [in position counts - encoder\n                               counts or microsteps] to start the\n                               triggering sequence.\n    :param interval_rev: When moving backwards, this is the interval [in\n                         position counts - encoder counts or microsteps] at\n                         which to output the trigger pulses.\n    :param num_pulses_rev: Number of output pulses during a backwards move.\n    :param pulse_width: Trigger output pulse width\n                        (from 1 \u00b5s to 1000000 \u00b5s).\n    :param num_cycles: Number of forward/reverse move cycles.\n    \"\"\"\n    payload = st.pack(\n        \"&lt;Hllllllll\",\n        Kdc._CHANNEL,\n        start_position_fwd,\n        interval_fwd,\n        num_pulses_fwd,\n        start_position_rev,\n        interval_rev,\n        num_pulses_rev,\n        pulse_width,\n        num_cycles,\n    )\n    await self.send(\n        Message(\n            MGMSG.MOT_SET_KCUBEPOSTRIGPARAMS,\n            data=payload,\n        )\n    )\n</code></pre>"},{"location":"sections/cube/kcube/kdc101/#thorlabs_cube.driver.kcube.kdc.Kdc.set_trigger_io_config","title":"<code>set_trigger_io_config(mode1, polarity1, mode2, polarity2)</code>  <code>async</code>","text":"<p>Set trigger intput/output parameters.</p> <p>The K-Cube motor controllers have two bidirectional trigger ports (TRIG1 and TRIG2) that can be used to read an external logic signal or output a logic level to control external equipment. Either of them can be independently configured as an input or an output and the active logic state can be selected High or Low to suit the requirements of the application. Electrically the ports output 5 Volt logic signals and are designed to be driven from a 5 Volt logic. When the port is used in the input mode, the logic levels are TTL compatible, i.e. a voltage level less than 0.8 Volt will be recognised as a logic LOW and a level greater than 2.4 Volt as a logic HIGH. The input contains a weak pull-up, so the state of the input with nothing connected will default to a logic HIGH. The weak pull-up feature allows a passive device, such as a mechanical switch to be connected directly to the input. When the port is used as an output it provides a push-pull drive of 5 Volts, with the maximum current limited to approximately 8 mA. The current limit prevents damage when the output is accidentally shorted to ground or driven to the opposite logic state by external circuity.</p> <p>Warning: do not drive the TRIG ports from any voltage source that can produce an output in excess of the normal 0 to 5 Volt logic level range. In any case the voltage at the TRIG ports must be limited to -0.25 to +5.25 Volts.</p> <p>Input Trigger Modes</p> <p>When configured as an input, the TRIG ports can be used as a general purpose digital input, or for triggering a relative, absolute or home move as follows:</p> <ul> <li>0x00: The trigger IO is disabled</li> <li>0x01: General purpose logic input (read through status bits using the   :py:meth:<code>get_status_bits()   &lt;thorlabs_cube.driver.tcube.tdc.Tdc.get_status_bits&gt;</code> method)</li> <li>0x02: Input trigger for relative move</li> <li>0x03: Input trigger for absolute move</li> <li>0x04: Input trigger for home move</li> </ul> <p>When used for triggering a move, the port is edge sensitive. In other words, it has to see a transition from the inactive to the active logic state (Low-&gt;High or High-&gt;Low) for the trigger input to be recognized. For the same reason a sustained logic level will not trigger repeated moves. The trigger input has to return to its inactive state first in order to start the next trigger.</p> <p>Output Trigger Modes</p> <p>When configured as an output, the TRIG ports can be used as a general purpose digital output, or to indicate motion status or to produce a trigger pulse at configurable positions as follows:</p> <ul> <li>0x0A: General purpose logic output (set using the         :py:meth:<code>set_digital_outputs_config()         &lt;Kdc.set_digital_outputs_config&gt;</code> method).</li> <li>0x0B: Trigger output active (level) when motor 'in motion'. The         output trigger goes high (5V) or low (0V) (as set in the         polarity1 and polarity2 parameters) when the stage is         in motion.</li> <li>0x0C: Trigger output active (level) when motor at 'maximum velocity'.</li> <li>0x0D: Trigger output active (pulsed) at pre-defined positions moving         forward (set using start_position_fwd,         interval_fwd, num_pulses_fwd and pulse_width parameters in the         :py:meth:<code>set_position_trigger_parameters()         &lt;Kdc.set_position_trigger_parameters&gt;</code> message). Only one         Trigger port at a time can be set to this mode.</li> <li>0x0E: Trigger output active (pulsed) at pre-defined positions moving         backwards (set using start_position_rev, interval_rev,         num_pulses_rev and pulse_width parameters in the         :py:meth:<code>set_position_trigger_parameters()         &lt;Kdc.set_position_trigger_parameters&gt;</code> message). Only one         Trigger port at a time can be set to this mode.</li> <li>0x0F: Trigger output active (pulsed) at pre-defined positions moving         forwards and backward. Only one Trigger port at a time can be         set to this mode.</li> </ul> <p>:param mode1: TRIG1 operating mode :param polarity1: The active state of TRIG1 (i.e. logic high or                   logic low) :param mode2: TRIG2 operating mode :param polarity2: The active state of TRIG2 (i.e. logic high or                   logic low)</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kdc.py</code> <pre><code>async def set_trigger_io_config(\n    self, mode1: int, polarity1: int, mode2: int, polarity2: int\n) -&gt; None:\n    \"\"\"Set trigger intput/output parameters.\n\n    The K-Cube motor controllers have two bidirectional trigger ports\n    (TRIG1 and TRIG2) that can be used to read an external logic signal or\n    output a logic level to control external equipment. Either of them can\n    be independently configured as an input or an output and the active\n    logic state can be selected High or Low to suit the requirements of the\n    application. Electrically the ports output 5 Volt logic signals and are\n    designed to be driven from a 5 Volt logic. When the port is used in the\n    input mode, the logic levels are TTL compatible, i.e. a voltage level\n    less than 0.8 Volt will be recognised as a logic LOW and a level\n    greater than 2.4 Volt as a logic HIGH. The input contains a weak\n    pull-up, so the state of the input with nothing connected will default\n    to a logic HIGH. The weak pull-up feature allows a passive device, such\n    as a mechanical switch to be connected directly to the input. When the\n    port is used as an output it provides a push-pull drive of 5 Volts,\n    with the maximum current limited to approximately 8 mA. The current\n    limit prevents damage when the output is accidentally shorted to ground\n    or driven to the opposite logic state by external circuity.\n\n    **Warning**: do not drive the TRIG ports from any voltage source that\n    can produce an output in excess of the normal 0 to 5 Volt logic level\n    range. In any case the voltage at the TRIG ports must be limited to\n    -0.25 to +5.25 Volts.\n\n    **Input Trigger Modes**\\n\n    When configured as an input, the TRIG ports can be used as a general\n    purpose digital input, or for triggering a relative, absolute or home\n    move as follows:\n\n    * 0x00: The trigger IO is disabled\n    * 0x01: General purpose logic input (read through status bits using the\n      :py:meth:`get_status_bits()\n      &lt;thorlabs_cube.driver.tcube.tdc.Tdc.get_status_bits&gt;` method)\n    * 0x02: Input trigger for relative move\n    * 0x03: Input trigger for absolute move\n    * 0x04: Input trigger for home move\n\n    When used for triggering a move, the port is edge sensitive. In other\n    words, it has to see a transition from the inactive to the active logic\n    state (Low-&gt;High or High-&gt;Low) for the trigger input to be recognized.\n    For the same reason a sustained logic level will not trigger repeated\n    moves. The trigger input has to return to its inactive state first in\n    order to start the next trigger.\n\n    **Output Trigger Modes**\\n\n    When configured as an output, the TRIG ports can be used as a general\n    purpose digital output, or to indicate motion status or to produce a\n    trigger pulse at configurable positions as follows:\n\n    * 0x0A: General purpose logic output (set using the\n            :py:meth:`set_digital_outputs_config()\n            &lt;Kdc.set_digital_outputs_config&gt;` method).\n    * 0x0B: Trigger output active (level) when motor 'in motion'. The\n            output trigger goes high (5V) or low (0V) (as set in the\n            polarity1 and polarity2 parameters) when the stage is\n            in motion.\n    * 0x0C: Trigger output active (level) when motor at 'maximum velocity'.\n    * 0x0D: Trigger output active (pulsed) at pre-defined positions moving\n            forward (set using start_position_fwd,\n            interval_fwd, num_pulses_fwd and pulse_width parameters in the\n            :py:meth:`set_position_trigger_parameters()\n            &lt;Kdc.set_position_trigger_parameters&gt;` message). Only one\n            Trigger port at a time can be set to this mode.\n    * 0x0E: Trigger output active (pulsed) at pre-defined positions moving\n            backwards (set using start_position_rev, interval_rev,\n            num_pulses_rev and pulse_width parameters in the\n            :py:meth:`set_position_trigger_parameters()\n            &lt;Kdc.set_position_trigger_parameters&gt;` message). Only one\n            Trigger port at a time can be set to this mode.\n    * 0x0F: Trigger output active (pulsed) at pre-defined positions moving\n            forwards and backward. Only one Trigger port at a time can be\n            set to this mode.\n\n    :param mode1: TRIG1 operating mode\n    :param polarity1: The active state of TRIG1 (i.e. logic high or\n                      logic low)\n    :param mode2: TRIG2 operating mode\n    :param polarity2: The active state of TRIG2 (i.e. logic high or\n                      logic low)\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HHHHHQH\",\n        Kdc._CHANNEL,\n        mode1,\n        polarity1,\n        mode2,\n        polarity2,\n        Kdc._RESERVED,\n        Kdc._RESERVED,\n    )\n    await self.send(Message(MGMSG.MOT_SET_KCUBETRIGIOCONFIG, data=payload))\n</code></pre>"},{"location":"sections/cube/kcube/kpa101/","title":"KPA101","text":""},{"location":"sections/cube/kcube/kpa101/#controller-description","title":"Controller Description","text":"<p>The KPA101 is a compact single-channel K-Cube controller from Thorlabs designed for automatic alignment of optical components using Position-Sensitive Detectors (PSDs). It provides real-time, feedback-based control for high-precision optical alignment tasks. The KPA101 is ideal for dynamic alignment in optical systems and integrates seamlessly with Thorlabs\u2019 PSDs and alignment peripherals. It features USB connectivity for computer control via Thorlabs\u2019 Kinesis Software or QuantumION's Thorlabs Cube Repository.</p>"},{"location":"sections/cube/kcube/kpa101/#controller-use-cases","title":"Controller Use-Cases","text":"<ul> <li>KPA101 is used in applications requiring automated optical alignment, such as:<ol> <li>Beam Stabilization: Maintaining optical beam alignment during system operation.</li> <li>Optical System Setup: Automating the alignment of optical components like lenses and mirrors.</li> <li>Laser Systems: Dynamic alignment of laser beams for stability and throughput optimization.</li> </ol> </li> </ul>"},{"location":"sections/cube/kcube/kpa101/#peripherals-examples","title":"Peripherals Examples","text":"<ul> <li>Position-Sensitive Detectors </li> <li>Motorized Mirror Mounts </li> <li>Auto-Aligning Modules</li> </ul>"},{"location":"sections/cube/kcube/kpa101/#api-reference","title":"API Reference","text":"<p>               Bases: <code>Tpa</code></p> <p>KPA101 Position Sensing Detector Auto Aligner driver implementation.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kpa.py</code> <pre><code>class Kpa(Tpa):\n    \"\"\"KPA101 Position Sensing Detector Auto Aligner driver implementation.\"\"\"\n\n    def __init__(self, serial_dev: str) -&gt; None:\n        \"\"\"Initialize the KPA101 driver.\n\n        :param serial_dev: Serial device identifier.\n        \"\"\"\n        super().__init__(serial_dev)\n        self.loop_params = None\n        self.status_report_counter = 0\n\n    async def handle_message(self, msg: Message) -&gt; None:\n        \"\"\"Handle incoming messages from the KPA101 device.\n\n        :param msg: Message object received from the device.\n        \"\"\"\n        msg_id = msg.id\n        data = msg.data\n\n        if msg_id == MGMSG.HW_DISCONNECT:\n            raise MsgError(\"Error: Please disconnect the KPA101\")\n\n        elif msg_id == MGMSG.HW_RESPONSE:\n            raise MsgError(\"Hardware error, please disconnect and reconnect the KPA101\")\n\n        elif msg_id == MGMSG.QUAD_GET_STATUSUPDATE:\n            x_diff, y_diff, sum_val, x_pos, y_pos, status_bits = st.unpack(\n                \"&lt;hhIhhI\", data[6:20]\n            )\n\n            # Update internal state variables with the extracted values\n            self.x_diff = x_diff\n            self.y_diff = y_diff\n            self.sum_val = sum_val\n            self.x_pos = x_pos\n            self.y_pos = y_pos\n            self.status_bits = status_bits\n\n            if self.status_report_counter == 25:\n                self.status_report_counter = 0\n                await self.send(Message(MGMSG.QUAD_ACK_STATUSUPDATE))\n            else:\n                self.status_report_counter += 1\n\n    async def set_trigger_config(\n        self,\n        trig1_mode: int,\n        trig1_polarity: int,\n        trig1_sum_min: int,\n        trig1_sum_max: int,\n        trig1_diff_threshold: int,\n        trig2_mode: int,\n        trig2_polarity: int,\n        trig2_sum_min: int,\n        trig2_sum_max: int,\n        trig2_diff_threshold: int,\n    ) -&gt; None:\n        \"\"\"Set trigger configuration for both TRIG1 and TRIG2.\n\n        :param trig1_mode: TRIG1 operating mode.\n        :param trig1_polarity: TRIG1 polarity.\n        :param trig1_sum_min: TRIG1 sum minimum.\n        :param trig1_sum_max: TRIG1 sum maximum.\n        :param trig1_diff_threshold: TRIG1 differential threshold.\n        :param trig2_mode: TRIG2 operating mode.\n        :param trig2_polarity: TRIG2 polarity.\n        :param trig2_sum_min: TRIG2 sum minimum.\n        :param trig2_sum_max: TRIG2 sum maximum.\n        :param trig2_diff_threshold: TRIG2 differential threshold.\n        \"\"\"\n\n        payload = st.pack(\n            \"&lt;HHHHHHHHHHHHHH\",\n            QUADMSG.QUAD_KPA_TRIGIO_SUB_ID.value,\n            trig1_mode,\n            trig1_polarity,\n            trig1_sum_min,\n            trig1_sum_max,\n            trig1_diff_threshold,\n            trig2_mode,\n            trig2_polarity,\n            trig2_sum_min,\n            trig2_sum_max,\n            trig2_diff_threshold,\n            Kpa._RESERVED,\n            Kpa._RESERVED,\n            Kpa._RESERVED,\n        )\n        await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n\n    async def get_trigger_config(\n        self,\n    ) -&gt; tuple[int, int, int, int, int, int, int, int, int, int, int, int, int]:\n        \"\"\"Get trigger configuration for both TRIG1 and TRIG2.\n\n        :return: A tuple containing trigger configuration parameters for TRIG1 and TRIG2.\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.QUAD_REQ_PARAMS,\n            [MGMSG.QUAD_GET_PARAMS],\n            param1=QUADMSG.QUAD_KPA_TRIGIO_SUB_ID.value,\n        )\n\n        return st.unpack(\"&lt;HHHHHHHHHHHHHHHHH\", get_msg.data)[1:]\n\n    async def set_digital_outputs(self, trigOne: int, trigTwo: int) -&gt; None:\n        \"\"\"Set digital outputs for TRIG1 and TRIG2.\n\n        :param digital_outputs: Status of TRIG1 and TRIG2 outputs.\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HBBH\",\n            QUADMSG.QUAD_KPA_DIGOPS_SUB_ID.value,\n            trigOne,\n            trigTwo,\n            Kpa._RESERVED,\n        )\n        await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n\n    async def get_digital_outputs(self) -&gt; Tuple[int, int]:\n        \"\"\"Get digital outputs for TRIG1 and TRIG2.\n\n        :return: Status of TRIG1 and TRIG2 outputs.\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.QUAD_REQ_PARAMS,\n            [MGMSG.QUAD_GET_PARAMS],\n            param1=QUADMSG.QUAD_KPA_DIGOPS_SUB_ID.value,\n        )\n        return st.unpack(\"&lt;HHHHHHHH\", get_msg.data)[1]\n</code></pre>"},{"location":"sections/cube/kcube/kpa101/#thorlabs_cube.driver.kcube.kpa.Kpa.__init__","title":"<code>__init__(serial_dev)</code>","text":"<p>Initialize the KPA101 driver.</p> <p>:param serial_dev: Serial device identifier.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kpa.py</code> <pre><code>def __init__(self, serial_dev: str) -&gt; None:\n    \"\"\"Initialize the KPA101 driver.\n\n    :param serial_dev: Serial device identifier.\n    \"\"\"\n    super().__init__(serial_dev)\n    self.loop_params = None\n    self.status_report_counter = 0\n</code></pre>"},{"location":"sections/cube/kcube/kpa101/#thorlabs_cube.driver.kcube.kpa.Kpa.get_digital_outputs","title":"<code>get_digital_outputs()</code>  <code>async</code>","text":"<p>Get digital outputs for TRIG1 and TRIG2.</p> <p>:return: Status of TRIG1 and TRIG2 outputs.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kpa.py</code> <pre><code>async def get_digital_outputs(self) -&gt; Tuple[int, int]:\n    \"\"\"Get digital outputs for TRIG1 and TRIG2.\n\n    :return: Status of TRIG1 and TRIG2 outputs.\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.QUAD_REQ_PARAMS,\n        [MGMSG.QUAD_GET_PARAMS],\n        param1=QUADMSG.QUAD_KPA_DIGOPS_SUB_ID.value,\n    )\n    return st.unpack(\"&lt;HHHHHHHH\", get_msg.data)[1]\n</code></pre>"},{"location":"sections/cube/kcube/kpa101/#thorlabs_cube.driver.kcube.kpa.Kpa.get_trigger_config","title":"<code>get_trigger_config()</code>  <code>async</code>","text":"<p>Get trigger configuration for both TRIG1 and TRIG2.</p> <p>:return: A tuple containing trigger configuration parameters for TRIG1 and TRIG2.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kpa.py</code> <pre><code>async def get_trigger_config(\n    self,\n) -&gt; tuple[int, int, int, int, int, int, int, int, int, int, int, int, int]:\n    \"\"\"Get trigger configuration for both TRIG1 and TRIG2.\n\n    :return: A tuple containing trigger configuration parameters for TRIG1 and TRIG2.\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.QUAD_REQ_PARAMS,\n        [MGMSG.QUAD_GET_PARAMS],\n        param1=QUADMSG.QUAD_KPA_TRIGIO_SUB_ID.value,\n    )\n\n    return st.unpack(\"&lt;HHHHHHHHHHHHHHHHH\", get_msg.data)[1:]\n</code></pre>"},{"location":"sections/cube/kcube/kpa101/#thorlabs_cube.driver.kcube.kpa.Kpa.handle_message","title":"<code>handle_message(msg)</code>  <code>async</code>","text":"<p>Handle incoming messages from the KPA101 device.</p> <p>:param msg: Message object received from the device.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kpa.py</code> <pre><code>async def handle_message(self, msg: Message) -&gt; None:\n    \"\"\"Handle incoming messages from the KPA101 device.\n\n    :param msg: Message object received from the device.\n    \"\"\"\n    msg_id = msg.id\n    data = msg.data\n\n    if msg_id == MGMSG.HW_DISCONNECT:\n        raise MsgError(\"Error: Please disconnect the KPA101\")\n\n    elif msg_id == MGMSG.HW_RESPONSE:\n        raise MsgError(\"Hardware error, please disconnect and reconnect the KPA101\")\n\n    elif msg_id == MGMSG.QUAD_GET_STATUSUPDATE:\n        x_diff, y_diff, sum_val, x_pos, y_pos, status_bits = st.unpack(\n            \"&lt;hhIhhI\", data[6:20]\n        )\n\n        # Update internal state variables with the extracted values\n        self.x_diff = x_diff\n        self.y_diff = y_diff\n        self.sum_val = sum_val\n        self.x_pos = x_pos\n        self.y_pos = y_pos\n        self.status_bits = status_bits\n\n        if self.status_report_counter == 25:\n            self.status_report_counter = 0\n            await self.send(Message(MGMSG.QUAD_ACK_STATUSUPDATE))\n        else:\n            self.status_report_counter += 1\n</code></pre>"},{"location":"sections/cube/kcube/kpa101/#thorlabs_cube.driver.kcube.kpa.Kpa.set_digital_outputs","title":"<code>set_digital_outputs(trigOne, trigTwo)</code>  <code>async</code>","text":"<p>Set digital outputs for TRIG1 and TRIG2.</p> <p>:param digital_outputs: Status of TRIG1 and TRIG2 outputs.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kpa.py</code> <pre><code>async def set_digital_outputs(self, trigOne: int, trigTwo: int) -&gt; None:\n    \"\"\"Set digital outputs for TRIG1 and TRIG2.\n\n    :param digital_outputs: Status of TRIG1 and TRIG2 outputs.\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HBBH\",\n        QUADMSG.QUAD_KPA_DIGOPS_SUB_ID.value,\n        trigOne,\n        trigTwo,\n        Kpa._RESERVED,\n    )\n    await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/kcube/kpa101/#thorlabs_cube.driver.kcube.kpa.Kpa.set_trigger_config","title":"<code>set_trigger_config(trig1_mode, trig1_polarity, trig1_sum_min, trig1_sum_max, trig1_diff_threshold, trig2_mode, trig2_polarity, trig2_sum_min, trig2_sum_max, trig2_diff_threshold)</code>  <code>async</code>","text":"<p>Set trigger configuration for both TRIG1 and TRIG2.</p> <p>:param trig1_mode: TRIG1 operating mode. :param trig1_polarity: TRIG1 polarity. :param trig1_sum_min: TRIG1 sum minimum. :param trig1_sum_max: TRIG1 sum maximum. :param trig1_diff_threshold: TRIG1 differential threshold. :param trig2_mode: TRIG2 operating mode. :param trig2_polarity: TRIG2 polarity. :param trig2_sum_min: TRIG2 sum minimum. :param trig2_sum_max: TRIG2 sum maximum. :param trig2_diff_threshold: TRIG2 differential threshold.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kpa.py</code> <pre><code>async def set_trigger_config(\n    self,\n    trig1_mode: int,\n    trig1_polarity: int,\n    trig1_sum_min: int,\n    trig1_sum_max: int,\n    trig1_diff_threshold: int,\n    trig2_mode: int,\n    trig2_polarity: int,\n    trig2_sum_min: int,\n    trig2_sum_max: int,\n    trig2_diff_threshold: int,\n) -&gt; None:\n    \"\"\"Set trigger configuration for both TRIG1 and TRIG2.\n\n    :param trig1_mode: TRIG1 operating mode.\n    :param trig1_polarity: TRIG1 polarity.\n    :param trig1_sum_min: TRIG1 sum minimum.\n    :param trig1_sum_max: TRIG1 sum maximum.\n    :param trig1_diff_threshold: TRIG1 differential threshold.\n    :param trig2_mode: TRIG2 operating mode.\n    :param trig2_polarity: TRIG2 polarity.\n    :param trig2_sum_min: TRIG2 sum minimum.\n    :param trig2_sum_max: TRIG2 sum maximum.\n    :param trig2_diff_threshold: TRIG2 differential threshold.\n    \"\"\"\n\n    payload = st.pack(\n        \"&lt;HHHHHHHHHHHHHH\",\n        QUADMSG.QUAD_KPA_TRIGIO_SUB_ID.value,\n        trig1_mode,\n        trig1_polarity,\n        trig1_sum_min,\n        trig1_sum_max,\n        trig1_diff_threshold,\n        trig2_mode,\n        trig2_polarity,\n        trig2_sum_min,\n        trig2_sum_max,\n        trig2_diff_threshold,\n        Kpa._RESERVED,\n        Kpa._RESERVED,\n        Kpa._RESERVED,\n    )\n    await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/kcube/kpz101/","title":"KPZ101","text":""},{"location":"sections/cube/kcube/kpz101/#controller-description","title":"Controller Description","text":"<p>The KPZ101 is a compact single-channel K-Cube controller from Thorlabs designed for precise control of piezoelectric actuators. It provides high-resolution control with nanometer-level precision, making it ideal for applications requiring ultra-fine positioning adjustments. The KPZ101 supports closed-loop operation with feedback from piezo sensors and features USB connectivity for computer control via Thorlabs\u2019 Kinesis Software or QuantumION's Thorlabs Cube Repository.</p>"},{"location":"sections/cube/kcube/kpz101/#controller-use-cases","title":"Controller Use-Cases","text":"<ul> <li>KPZ101 is commonly used in applications requiring high-precision motion control, such as:<ol> <li>Nanopositioning: Precise adjustments in optical systems.</li> <li>Interferometry: Fine control of optical path lengths for measurement accuracy.</li> <li>Microscopy: Sub-micron sample positioning and stage control.</li> </ol> </li> </ul>"},{"location":"sections/cube/kcube/kpz101/#peripherals-examples","title":"Peripherals Examples","text":"<ul> <li>Piezoelectric Actuators</li> </ul> <ul> <li>Piezo-Driven Mirror Mounts</li> </ul> <ul> <li>Piezo Translation Stages</li> </ul>"},{"location":"sections/cube/kcube/kpz101/#api-reference","title":"API Reference","text":"<p>               Bases: <code>Tpz</code></p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kpz.py</code> <pre><code>class Kpz(Tpz):\n\n    async def set_kcubemmi_params(\n        self,\n        js_mode: int,\n        js_volt_gearbox: int,\n        js_volt_step: int,\n        dir_sense: int,\n        preset_volt1: int,\n        preset_volt2: int,\n        disp_brightness: int,\n        disp_timeout: int,\n        disp_dim_level: int,\n    ) -&gt; None:\n        \"\"\"Set the KCube MMI parameters.\n\n        :param js_mode: The mode of joystick (JSMODE).\n        :param js_volt_gearbox: The rate of change of voltage for the joystick.\n        :param js_volt_step: The voltage step size when JSMODE is jog mode.\n        :param dir_sense: The direction of joystick motion.\n        :param preset_volt1: Preset voltage 1 for \"Go To\" mode.\n        :param preset_volt2: Preset voltage 2 for \"Go To\" mode.\n        :param disp_brightness: The brightness of the display.\n        :param disp_timeout: The timeout for display dimming.\n        :param disp_dim_level: The dimming level for the display.\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HHHLHLLHHHHHHH\",\n            Kpz._CHANNEL,\n            js_mode,\n            js_volt_gearbox,\n            js_volt_step,\n            dir_sense,\n            preset_volt1,\n            preset_volt2,\n            disp_brightness,\n            disp_timeout,\n            disp_dim_level,\n            Kpz._RESERVED,\n            Kpz._RESERVED,\n            Kpz._RESERVED,\n            Kpz._RESERVED,\n        )\n        await self.send(Message(MGMSG.KPZ_SET_KCUBEMMIPARAMS, data=payload))\n\n    async def get_kcubemmi_params(\n        self,\n    ) -&gt; tuple[int, int, int, int, int, int, int, int, int, int, int, int, int]:\n        \"\"\"Get the KCube MMI parameters.\n\n        :return: A tuple containing the KCube MMI parameters such as joystick mode,\n        voltage gearbox, voltage step, direction sense, preset voltages, display\n        brightness, timeout, and dim level. Purpose descriptions found in set_kcubemmi_params()\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.KPZ_REQ_KCUBEMMIPARAMS, [MGMSG.KPZ_GET_KCUBEMMIPARAMS], Kpz._CHANNEL\n        )\n\n        return st.unpack(\"&lt;HHHLHLLHHHHHHH\", get_msg.data[6:])\n\n    async def set_trigio_config(\n        self, trig1_mode: int, trig1_polarity: int, trig2_mode: int, trig2_polarity: int\n    ) -&gt; None:\n        \"\"\"Set the TRIG1 and TRIG2 input/output configuration.\n\n        :param trig1_mode: The mode of TRIG1.\n        :param trig1_polarity: The polarity of TRIG1.\n        :param trig2_mode: The mode of TRIG2.\n        :param trig2_polarity: The polarity of TRIG2.\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HHHHHHHHHHH\",\n            Kpz._CHANNEL,\n            trig1_mode,\n            trig1_polarity,\n            trig2_mode,\n            trig2_polarity,\n            Kpz._RESERVED,\n            Kpz._RESERVED,\n            Kpz._RESERVED,\n            Kpz._RESERVED,\n            Kpz._RESERVED,\n            Kpz._RESERVED,\n        )\n        await self.send(Message(MGMSG.KPZ_SET_KCUBETRIGIOCONFIG, data=payload))\n\n    async def get_trigio_config(\n        self,\n    ) -&gt; tuple[int, int, int, int, int, int, int, int, int, int, int]:\n        \"\"\"Get the TRIG1 and TRIG2 input/output configuration.\n\n        :return: A tuple containing the Trigger IO\n        configuration parameters for TRIG1 and TRIG2 (mode, polarity).\n        Purpose description can be found in set_trigio_config()\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.KPZ_REQ_KCUBETRIGIOCONFIG,\n            [MGMSG.KPZ_GET_KCUBETRIGIOCONFIG],\n            Kpz._CHANNEL,\n        )\n        return st.unpack(\"&lt;HHHHHHHHHHH\", get_msg.data[6:])\n</code></pre>"},{"location":"sections/cube/kcube/kpz101/#thorlabs_cube.driver.kcube.kpz.Kpz.get_kcubemmi_params","title":"<code>get_kcubemmi_params()</code>  <code>async</code>","text":"<p>Get the KCube MMI parameters.</p> <p>:return: A tuple containing the KCube MMI parameters such as joystick mode, voltage gearbox, voltage step, direction sense, preset voltages, display brightness, timeout, and dim level. Purpose descriptions found in set_kcubemmi_params()</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kpz.py</code> <pre><code>async def get_kcubemmi_params(\n    self,\n) -&gt; tuple[int, int, int, int, int, int, int, int, int, int, int, int, int]:\n    \"\"\"Get the KCube MMI parameters.\n\n    :return: A tuple containing the KCube MMI parameters such as joystick mode,\n    voltage gearbox, voltage step, direction sense, preset voltages, display\n    brightness, timeout, and dim level. Purpose descriptions found in set_kcubemmi_params()\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.KPZ_REQ_KCUBEMMIPARAMS, [MGMSG.KPZ_GET_KCUBEMMIPARAMS], Kpz._CHANNEL\n    )\n\n    return st.unpack(\"&lt;HHHLHLLHHHHHHH\", get_msg.data[6:])\n</code></pre>"},{"location":"sections/cube/kcube/kpz101/#thorlabs_cube.driver.kcube.kpz.Kpz.get_trigio_config","title":"<code>get_trigio_config()</code>  <code>async</code>","text":"<p>Get the TRIG1 and TRIG2 input/output configuration.</p> <p>:return: A tuple containing the Trigger IO configuration parameters for TRIG1 and TRIG2 (mode, polarity). Purpose description can be found in set_trigio_config()</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kpz.py</code> <pre><code>async def get_trigio_config(\n    self,\n) -&gt; tuple[int, int, int, int, int, int, int, int, int, int, int]:\n    \"\"\"Get the TRIG1 and TRIG2 input/output configuration.\n\n    :return: A tuple containing the Trigger IO\n    configuration parameters for TRIG1 and TRIG2 (mode, polarity).\n    Purpose description can be found in set_trigio_config()\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.KPZ_REQ_KCUBETRIGIOCONFIG,\n        [MGMSG.KPZ_GET_KCUBETRIGIOCONFIG],\n        Kpz._CHANNEL,\n    )\n    return st.unpack(\"&lt;HHHHHHHHHHH\", get_msg.data[6:])\n</code></pre>"},{"location":"sections/cube/kcube/kpz101/#thorlabs_cube.driver.kcube.kpz.Kpz.set_kcubemmi_params","title":"<code>set_kcubemmi_params(js_mode, js_volt_gearbox, js_volt_step, dir_sense, preset_volt1, preset_volt2, disp_brightness, disp_timeout, disp_dim_level)</code>  <code>async</code>","text":"<p>Set the KCube MMI parameters.</p> <p>:param js_mode: The mode of joystick (JSMODE). :param js_volt_gearbox: The rate of change of voltage for the joystick. :param js_volt_step: The voltage step size when JSMODE is jog mode. :param dir_sense: The direction of joystick motion. :param preset_volt1: Preset voltage 1 for \"Go To\" mode. :param preset_volt2: Preset voltage 2 for \"Go To\" mode. :param disp_brightness: The brightness of the display. :param disp_timeout: The timeout for display dimming. :param disp_dim_level: The dimming level for the display.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kpz.py</code> <pre><code>async def set_kcubemmi_params(\n    self,\n    js_mode: int,\n    js_volt_gearbox: int,\n    js_volt_step: int,\n    dir_sense: int,\n    preset_volt1: int,\n    preset_volt2: int,\n    disp_brightness: int,\n    disp_timeout: int,\n    disp_dim_level: int,\n) -&gt; None:\n    \"\"\"Set the KCube MMI parameters.\n\n    :param js_mode: The mode of joystick (JSMODE).\n    :param js_volt_gearbox: The rate of change of voltage for the joystick.\n    :param js_volt_step: The voltage step size when JSMODE is jog mode.\n    :param dir_sense: The direction of joystick motion.\n    :param preset_volt1: Preset voltage 1 for \"Go To\" mode.\n    :param preset_volt2: Preset voltage 2 for \"Go To\" mode.\n    :param disp_brightness: The brightness of the display.\n    :param disp_timeout: The timeout for display dimming.\n    :param disp_dim_level: The dimming level for the display.\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HHHLHLLHHHHHHH\",\n        Kpz._CHANNEL,\n        js_mode,\n        js_volt_gearbox,\n        js_volt_step,\n        dir_sense,\n        preset_volt1,\n        preset_volt2,\n        disp_brightness,\n        disp_timeout,\n        disp_dim_level,\n        Kpz._RESERVED,\n        Kpz._RESERVED,\n        Kpz._RESERVED,\n        Kpz._RESERVED,\n    )\n    await self.send(Message(MGMSG.KPZ_SET_KCUBEMMIPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/kcube/kpz101/#thorlabs_cube.driver.kcube.kpz.Kpz.set_trigio_config","title":"<code>set_trigio_config(trig1_mode, trig1_polarity, trig2_mode, trig2_polarity)</code>  <code>async</code>","text":"<p>Set the TRIG1 and TRIG2 input/output configuration.</p> <p>:param trig1_mode: The mode of TRIG1. :param trig1_polarity: The polarity of TRIG1. :param trig2_mode: The mode of TRIG2. :param trig2_polarity: The polarity of TRIG2.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/kpz.py</code> <pre><code>async def set_trigio_config(\n    self, trig1_mode: int, trig1_polarity: int, trig2_mode: int, trig2_polarity: int\n) -&gt; None:\n    \"\"\"Set the TRIG1 and TRIG2 input/output configuration.\n\n    :param trig1_mode: The mode of TRIG1.\n    :param trig1_polarity: The polarity of TRIG1.\n    :param trig2_mode: The mode of TRIG2.\n    :param trig2_polarity: The polarity of TRIG2.\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HHHHHHHHHHH\",\n        Kpz._CHANNEL,\n        trig1_mode,\n        trig1_polarity,\n        trig2_mode,\n        trig2_polarity,\n        Kpz._RESERVED,\n        Kpz._RESERVED,\n        Kpz._RESERVED,\n        Kpz._RESERVED,\n        Kpz._RESERVED,\n        Kpz._RESERVED,\n    )\n    await self.send(Message(MGMSG.KPZ_SET_KCUBETRIGIOCONFIG, data=payload))\n</code></pre>"},{"location":"sections/cube/kcube/ksc101/","title":"KSC101","text":""},{"location":"sections/cube/kcube/ksc101/#controller-description","title":"Controller Description","text":"<p>The KSC101 is a compact single-channel K-Cube controller from Thorlabs designed for precise control of solenoids. It enables accurate and reliable actuation of solenoids for applications that require controlled force or switching. The KSC101 provides adjustable current settings for solenoid operation and features USB connectivity for computer control via Thorlabs\u2019 Kinesis Software or QuantumION's Thorlabs Cube Repository.</p>"},{"location":"sections/cube/kcube/ksc101/#controller-use-cases","title":"Controller Use-Cases","text":"<ul> <li>KSC101 is used in applications requiring precise solenoid actuation, such as:<ol> <li>Optical Shutters: Controlled beam blocking or modulation in laser systems.</li> <li>Optomechanical Systems: Switching optical paths with high accuracy.</li> <li>Industrial Automation: Actuating mechanical locks or switches in precise operations.</li> </ol> </li> </ul>"},{"location":"sections/cube/kcube/ksc101/#peripherals-examples","title":"Peripherals Examples","text":"<ul> <li>Optical Shutters </li> <li>Motorized Flip Mounts </li> </ul>"},{"location":"sections/cube/kcube/ksc101/#api-reference","title":"API Reference","text":"<p>               Bases: <code>Tsc</code></p> <p>KSC101 K-Cube Solenoid Controller class</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/ksc.py</code> <pre><code>class Ksc(Tsc):\n    \"\"\"\n    KSC101 K-Cube Solenoid Controller class\n    \"\"\"\n\n    async def set_kcubemmi_params(\n        self,\n        js_mode: int,\n        js_max_vel: int,\n        js_accn: int,\n        dir_sense: int,\n        preset_pos1: int,\n        preset_pos2: int,\n        preset_pos3: int,\n        disp_brightness: int,\n        disp_timeout: int,\n        disp_dim_level: int,\n        js_sensitivity: int,\n    ) -&gt; None:\n        \"\"\"Set the KCube MMI (joystick) parameters.\n\n        :param js_mode: Joystick mode (1 = velocity control, 2 = jog mode, 3 = go-to-position mode).\n        :param js_max_vel: Maximum velocity for the joystick.\n        :param js_accn: Acceleration for the joystick.\n        :param dir_sense: Direction sense (normal or reversed).\n        :param preset_pos1: Preset position 1.\n        :param preset_pos2: Preset position 2.\n        :param preset_pos3: Preset position 3.\n        :param disp_brightness: Display brightness.\n        :param disp_timeout: Display timeout in ms.\n        :param disp_dim_level: Display dim level.\n        :param js_sensitivity: Joystick sensitivity.\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HHLLLHHLLLLH\",\n            Ksc._CHANNEL,\n            js_mode,\n            js_max_vel,\n            js_accn,\n            dir_sense,\n            preset_pos1,\n            preset_pos2,\n            preset_pos3,\n            disp_brightness,\n            disp_timeout,\n            disp_dim_level,\n            js_sensitivity,\n        )\n        await self.send(Message(MGMSG.MOT_SET_KCUBEMMIPARAMS, data=payload))\n\n    async def get_kcubemmi_params(\n        self,\n    ) -&gt; tuple[int, int, int, int, int, int, int, int, int, int, int]:\n        \"\"\"Get the KCube MMI (joystick) parameters.\n\n        :return: A tuple containing the joystick mode, max velocity,\n        acceleration, direction sense, preset positions, display\n        settings, and joystick sensitivity.\n        \"\"\"\n        payload = st.pack(\"&lt;H\", Ksc._CHANNEL)\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_KCUBEMMIPARAMS, [MGMSG.MOT_GET_KCUBEMMIPARAMS], data=payload\n        )\n\n        return st.unpack(\"&lt;HLLLHHLLLLH\", get_msg.data[2:])\n\n    async def set_kcubetrigio_config(\n        self, trig1_mode: int, trig1_polarity: int, trig2_mode: int, trig2_polarity: int\n    ) -&gt; None:\n        \"\"\"Set the KCube trigger I/O configuration parameters.\n\n        :param trig1_mode: Mode for Trigger 1 (input/output).\n        :param trig1_polarity: Polarity for Trigger 1 (high/low).\n        :param trig2_mode: Mode for Trigger 2 (input/output).\n        :param trig2_polarity: Polarity for Trigger 2 (high/low).\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HBBBB\",\n            Ksc._CHANNEL,\n            trig1_mode,\n            trig1_polarity,\n            trig2_mode,\n            trig2_polarity,\n        )\n\n        await self.send(Message(MGMSG.MOT_SET_KCUBETRIGIOCONFIG, data=payload))\n\n    async def get_kcubetrigio_config(self) -&gt; tuple[int, int, int, int]:\n        \"\"\"Get the KCube trigger I/O configuration parameters.\n\n        :return: A tuple containing the operating mode, and active state for\n        both Trigger 1 and Trigger 2. The active states can assume a High or Low\n        whereas, the operating modes can be both input and output respectively\n\n        Input State Operating Modes:\n\n            0x00 The trigger IO is disabled\n\n            0x01 General purpose logic input (read through status bits using the\n            MOT_GET_STATUSBITS message).\n\n            0x02 Input trigger for relative move.\n\n            0x03 Input trigger for absolute move.\n\n            0x04 Input trigger for home move.\n\n        Output State Operating Modes:\n\n            0x0A General purpose logic output (set using the MOD_SET_DIGOUTPUTS message).\n\n            0x0B Trigger output active (level) when motor 'in motion'. The output trigger goes high (5V)\n            or low (0V) (as set in the lTrig1Polarity and lTrig2Polarity parameters) when the stage is in\n            motion.\n\n            0x0C Trigger output active (level) when motor at 'max velocity'.\n\n            0x0D Trigger output active (pulsed) at pre-defined positions moving forward (set using\n            StartPosFwd, IntervalFwd, NumPulsesFwd and PulseWidth parameters in the\n            SetKCubePosTrigParams message). Only one Trigger port at a time can be set to this mode.\n\n            0x0E Trigger output active (pulsed) at pre-defined positions moving backwards (set using\n            StartPosRev, IntervalRev, NumPulsesRev and PulseWidth parameters in the\n            SetKCubePosTrigParams message). Only one Trigger port at a time can be set to this mode.\n\n            0x0F Trigger output active (pulsed) at pre-defined positions moving forwards and\n            backward. Only one Trigger port at a time can be set to this mode.\n        \"\"\"\n        payload = st.pack(\"&lt;H\", Ksc._CHANNEL)\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_KCUBETRIGIOCONFIG,\n            [MGMSG.MOT_GET_KCUBETRIGIOCONFIG],\n            data=payload,\n        )\n\n        return st.unpack(\"&lt;BBBB\", get_msg.data[2:])\n\n    async def set_kcubepostrig_params(\n        self,\n        start_pos_fwd: int,\n        interval_fwd: int,\n        num_pulses_fwd: int,\n        start_pos_rev: int,\n        interval_rev: int,\n        num_pulses_rev: int,\n        pulse_width: int,\n        num_cycles: int,\n    ) -&gt; None:\n        \"\"\"Set the KCube post-trigger parameters.\n\n        :param start_pos_fwd: Stage position to start the forward trigger sequence.\n        :param interval_fwd: Interval in encoder counts/microsteps for forward trigger pulses.\n        :param num_pulses_fwd: Number of output pulses during forward move.\n        :param start_pos_rev: Stage position to start the reverse trigger sequence.\n        :param interval_rev: Interval in encoder counts/microsteps for reverse trigger pulses.\n        :param num_pulses_rev: Number of output pulses during reverse move.\n        :param pulse_width: Trigger output pulse width (from 1 \u03bcs to 1,000,000 \u03bcs).\n        :param num_cycles: Number of forward/reverse cycles.\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HLLLLLLLL\",\n            Ksc._CHANNEL,\n            start_pos_fwd,\n            interval_fwd,\n            num_pulses_fwd,\n            start_pos_rev,\n            interval_rev,\n            num_pulses_rev,\n            pulse_width,\n            num_cycles,\n        )\n        await self.send(Message(MGMSG.MOT_SET_KCUBEPOSTRIGPARAMS, data=payload))\n\n    async def get_kcubepostrig_params(\n        self,\n    ) -&gt; tuple[int, int, int, int, int, int, int, int]:\n        \"\"\"Get the KCube post-trigger parameters.\n\n        :return: A tuple containing (start_pos_fwd, interval_fwd,\n        num_pulses_fwd, start_pos_rev, interval_rev, num_pulses_rev,\n        pulse_width, num_cycles).\n        \"\"\"\n        payload = st.pack(\"&lt;H\", Ksc._CHANNEL)\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_KCUBEPOSTRIGPARAMS,\n            [MGMSG.MOT_GET_KCUBEPOSTRIGPARAMS],\n            data=payload,\n        )\n\n        return st.unpack(\"&lt;LLLLLLLL\", get_msg.data[2:])\n</code></pre>"},{"location":"sections/cube/kcube/ksc101/#thorlabs_cube.driver.kcube.ksc.Ksc.get_kcubemmi_params","title":"<code>get_kcubemmi_params()</code>  <code>async</code>","text":"<p>Get the KCube MMI (joystick) parameters.</p> <p>:return: A tuple containing the joystick mode, max velocity, acceleration, direction sense, preset positions, display settings, and joystick sensitivity.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/ksc.py</code> <pre><code>async def get_kcubemmi_params(\n    self,\n) -&gt; tuple[int, int, int, int, int, int, int, int, int, int, int]:\n    \"\"\"Get the KCube MMI (joystick) parameters.\n\n    :return: A tuple containing the joystick mode, max velocity,\n    acceleration, direction sense, preset positions, display\n    settings, and joystick sensitivity.\n    \"\"\"\n    payload = st.pack(\"&lt;H\", Ksc._CHANNEL)\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_KCUBEMMIPARAMS, [MGMSG.MOT_GET_KCUBEMMIPARAMS], data=payload\n    )\n\n    return st.unpack(\"&lt;HLLLHHLLLLH\", get_msg.data[2:])\n</code></pre>"},{"location":"sections/cube/kcube/ksc101/#thorlabs_cube.driver.kcube.ksc.Ksc.get_kcubepostrig_params","title":"<code>get_kcubepostrig_params()</code>  <code>async</code>","text":"<p>Get the KCube post-trigger parameters.</p> <p>:return: A tuple containing (start_pos_fwd, interval_fwd, num_pulses_fwd, start_pos_rev, interval_rev, num_pulses_rev, pulse_width, num_cycles).</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/ksc.py</code> <pre><code>async def get_kcubepostrig_params(\n    self,\n) -&gt; tuple[int, int, int, int, int, int, int, int]:\n    \"\"\"Get the KCube post-trigger parameters.\n\n    :return: A tuple containing (start_pos_fwd, interval_fwd,\n    num_pulses_fwd, start_pos_rev, interval_rev, num_pulses_rev,\n    pulse_width, num_cycles).\n    \"\"\"\n    payload = st.pack(\"&lt;H\", Ksc._CHANNEL)\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_KCUBEPOSTRIGPARAMS,\n        [MGMSG.MOT_GET_KCUBEPOSTRIGPARAMS],\n        data=payload,\n    )\n\n    return st.unpack(\"&lt;LLLLLLLL\", get_msg.data[2:])\n</code></pre>"},{"location":"sections/cube/kcube/ksc101/#thorlabs_cube.driver.kcube.ksc.Ksc.get_kcubetrigio_config","title":"<code>get_kcubetrigio_config()</code>  <code>async</code>","text":"<p>Get the KCube trigger I/O configuration parameters.</p> <p>:return: A tuple containing the operating mode, and active state for both Trigger 1 and Trigger 2. The active states can assume a High or Low whereas, the operating modes can be both input and output respectively</p> <p>Input State Operating Modes:</p> <pre><code>0x00 The trigger IO is disabled\n\n0x01 General purpose logic input (read through status bits using the\nMOT_GET_STATUSBITS message).\n\n0x02 Input trigger for relative move.\n\n0x03 Input trigger for absolute move.\n\n0x04 Input trigger for home move.\n</code></pre> <p>Output State Operating Modes:</p> <pre><code>0x0A General purpose logic output (set using the MOD_SET_DIGOUTPUTS message).\n\n0x0B Trigger output active (level) when motor 'in motion'. The output trigger goes high (5V)\nor low (0V) (as set in the lTrig1Polarity and lTrig2Polarity parameters) when the stage is in\nmotion.\n\n0x0C Trigger output active (level) when motor at 'max velocity'.\n\n0x0D Trigger output active (pulsed) at pre-defined positions moving forward (set using\nStartPosFwd, IntervalFwd, NumPulsesFwd and PulseWidth parameters in the\nSetKCubePosTrigParams message). Only one Trigger port at a time can be set to this mode.\n\n0x0E Trigger output active (pulsed) at pre-defined positions moving backwards (set using\nStartPosRev, IntervalRev, NumPulsesRev and PulseWidth parameters in the\nSetKCubePosTrigParams message). Only one Trigger port at a time can be set to this mode.\n\n0x0F Trigger output active (pulsed) at pre-defined positions moving forwards and\nbackward. Only one Trigger port at a time can be set to this mode.\n</code></pre> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/ksc.py</code> <pre><code>async def get_kcubetrigio_config(self) -&gt; tuple[int, int, int, int]:\n    \"\"\"Get the KCube trigger I/O configuration parameters.\n\n    :return: A tuple containing the operating mode, and active state for\n    both Trigger 1 and Trigger 2. The active states can assume a High or Low\n    whereas, the operating modes can be both input and output respectively\n\n    Input State Operating Modes:\n\n        0x00 The trigger IO is disabled\n\n        0x01 General purpose logic input (read through status bits using the\n        MOT_GET_STATUSBITS message).\n\n        0x02 Input trigger for relative move.\n\n        0x03 Input trigger for absolute move.\n\n        0x04 Input trigger for home move.\n\n    Output State Operating Modes:\n\n        0x0A General purpose logic output (set using the MOD_SET_DIGOUTPUTS message).\n\n        0x0B Trigger output active (level) when motor 'in motion'. The output trigger goes high (5V)\n        or low (0V) (as set in the lTrig1Polarity and lTrig2Polarity parameters) when the stage is in\n        motion.\n\n        0x0C Trigger output active (level) when motor at 'max velocity'.\n\n        0x0D Trigger output active (pulsed) at pre-defined positions moving forward (set using\n        StartPosFwd, IntervalFwd, NumPulsesFwd and PulseWidth parameters in the\n        SetKCubePosTrigParams message). Only one Trigger port at a time can be set to this mode.\n\n        0x0E Trigger output active (pulsed) at pre-defined positions moving backwards (set using\n        StartPosRev, IntervalRev, NumPulsesRev and PulseWidth parameters in the\n        SetKCubePosTrigParams message). Only one Trigger port at a time can be set to this mode.\n\n        0x0F Trigger output active (pulsed) at pre-defined positions moving forwards and\n        backward. Only one Trigger port at a time can be set to this mode.\n    \"\"\"\n    payload = st.pack(\"&lt;H\", Ksc._CHANNEL)\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_KCUBETRIGIOCONFIG,\n        [MGMSG.MOT_GET_KCUBETRIGIOCONFIG],\n        data=payload,\n    )\n\n    return st.unpack(\"&lt;BBBB\", get_msg.data[2:])\n</code></pre>"},{"location":"sections/cube/kcube/ksc101/#thorlabs_cube.driver.kcube.ksc.Ksc.set_kcubemmi_params","title":"<code>set_kcubemmi_params(js_mode, js_max_vel, js_accn, dir_sense, preset_pos1, preset_pos2, preset_pos3, disp_brightness, disp_timeout, disp_dim_level, js_sensitivity)</code>  <code>async</code>","text":"<p>Set the KCube MMI (joystick) parameters.</p> <p>:param js_mode: Joystick mode (1 = velocity control, 2 = jog mode, 3 = go-to-position mode). :param js_max_vel: Maximum velocity for the joystick. :param js_accn: Acceleration for the joystick. :param dir_sense: Direction sense (normal or reversed). :param preset_pos1: Preset position 1. :param preset_pos2: Preset position 2. :param preset_pos3: Preset position 3. :param disp_brightness: Display brightness. :param disp_timeout: Display timeout in ms. :param disp_dim_level: Display dim level. :param js_sensitivity: Joystick sensitivity.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/ksc.py</code> <pre><code>async def set_kcubemmi_params(\n    self,\n    js_mode: int,\n    js_max_vel: int,\n    js_accn: int,\n    dir_sense: int,\n    preset_pos1: int,\n    preset_pos2: int,\n    preset_pos3: int,\n    disp_brightness: int,\n    disp_timeout: int,\n    disp_dim_level: int,\n    js_sensitivity: int,\n) -&gt; None:\n    \"\"\"Set the KCube MMI (joystick) parameters.\n\n    :param js_mode: Joystick mode (1 = velocity control, 2 = jog mode, 3 = go-to-position mode).\n    :param js_max_vel: Maximum velocity for the joystick.\n    :param js_accn: Acceleration for the joystick.\n    :param dir_sense: Direction sense (normal or reversed).\n    :param preset_pos1: Preset position 1.\n    :param preset_pos2: Preset position 2.\n    :param preset_pos3: Preset position 3.\n    :param disp_brightness: Display brightness.\n    :param disp_timeout: Display timeout in ms.\n    :param disp_dim_level: Display dim level.\n    :param js_sensitivity: Joystick sensitivity.\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HHLLLHHLLLLH\",\n        Ksc._CHANNEL,\n        js_mode,\n        js_max_vel,\n        js_accn,\n        dir_sense,\n        preset_pos1,\n        preset_pos2,\n        preset_pos3,\n        disp_brightness,\n        disp_timeout,\n        disp_dim_level,\n        js_sensitivity,\n    )\n    await self.send(Message(MGMSG.MOT_SET_KCUBEMMIPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/kcube/ksc101/#thorlabs_cube.driver.kcube.ksc.Ksc.set_kcubepostrig_params","title":"<code>set_kcubepostrig_params(start_pos_fwd, interval_fwd, num_pulses_fwd, start_pos_rev, interval_rev, num_pulses_rev, pulse_width, num_cycles)</code>  <code>async</code>","text":"<p>Set the KCube post-trigger parameters.</p> <p>:param start_pos_fwd: Stage position to start the forward trigger sequence. :param interval_fwd: Interval in encoder counts/microsteps for forward trigger pulses. :param num_pulses_fwd: Number of output pulses during forward move. :param start_pos_rev: Stage position to start the reverse trigger sequence. :param interval_rev: Interval in encoder counts/microsteps for reverse trigger pulses. :param num_pulses_rev: Number of output pulses during reverse move. :param pulse_width: Trigger output pulse width (from 1 \u03bcs to 1,000,000 \u03bcs). :param num_cycles: Number of forward/reverse cycles.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/ksc.py</code> <pre><code>async def set_kcubepostrig_params(\n    self,\n    start_pos_fwd: int,\n    interval_fwd: int,\n    num_pulses_fwd: int,\n    start_pos_rev: int,\n    interval_rev: int,\n    num_pulses_rev: int,\n    pulse_width: int,\n    num_cycles: int,\n) -&gt; None:\n    \"\"\"Set the KCube post-trigger parameters.\n\n    :param start_pos_fwd: Stage position to start the forward trigger sequence.\n    :param interval_fwd: Interval in encoder counts/microsteps for forward trigger pulses.\n    :param num_pulses_fwd: Number of output pulses during forward move.\n    :param start_pos_rev: Stage position to start the reverse trigger sequence.\n    :param interval_rev: Interval in encoder counts/microsteps for reverse trigger pulses.\n    :param num_pulses_rev: Number of output pulses during reverse move.\n    :param pulse_width: Trigger output pulse width (from 1 \u03bcs to 1,000,000 \u03bcs).\n    :param num_cycles: Number of forward/reverse cycles.\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HLLLLLLLL\",\n        Ksc._CHANNEL,\n        start_pos_fwd,\n        interval_fwd,\n        num_pulses_fwd,\n        start_pos_rev,\n        interval_rev,\n        num_pulses_rev,\n        pulse_width,\n        num_cycles,\n    )\n    await self.send(Message(MGMSG.MOT_SET_KCUBEPOSTRIGPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/kcube/ksc101/#thorlabs_cube.driver.kcube.ksc.Ksc.set_kcubetrigio_config","title":"<code>set_kcubetrigio_config(trig1_mode, trig1_polarity, trig2_mode, trig2_polarity)</code>  <code>async</code>","text":"<p>Set the KCube trigger I/O configuration parameters.</p> <p>:param trig1_mode: Mode for Trigger 1 (input/output). :param trig1_polarity: Polarity for Trigger 1 (high/low). :param trig2_mode: Mode for Trigger 2 (input/output). :param trig2_polarity: Polarity for Trigger 2 (high/low).</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/kcube/ksc.py</code> <pre><code>async def set_kcubetrigio_config(\n    self, trig1_mode: int, trig1_polarity: int, trig2_mode: int, trig2_polarity: int\n) -&gt; None:\n    \"\"\"Set the KCube trigger I/O configuration parameters.\n\n    :param trig1_mode: Mode for Trigger 1 (input/output).\n    :param trig1_polarity: Polarity for Trigger 1 (high/low).\n    :param trig2_mode: Mode for Trigger 2 (input/output).\n    :param trig2_polarity: Polarity for Trigger 2 (high/low).\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HBBBB\",\n        Ksc._CHANNEL,\n        trig1_mode,\n        trig1_polarity,\n        trig2_mode,\n        trig2_polarity,\n    )\n\n    await self.send(Message(MGMSG.MOT_SET_KCUBETRIGIOCONFIG, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/","title":"TDC001","text":""},{"location":"sections/cube/tcube/tdc001/#controller-description","title":"Controller Description","text":"<p>The TDC001 is a compact single-channel T-Cube controller from Thorlabs designed for precise control of DC servo motors. It is commonly used for positioning applications requiring fine adjustments. The TDC001 supports bidirectional motor control, with adjustable speed and position settings, and is compatible with Thorlabs\u2019 DC servo actuators. It features USB connectivity for computer control via Thorlabs\u2019 Kinesis Software or QuantumION's Thorlabs Cube Repository</p>"},{"location":"sections/cube/tcube/tdc001/#controller-use-cases","title":"Controller Use-Cases","text":"<ul> <li>TDC001 is used in applications requiring precise motion control, such as:<ol> <li>Optical Alignment: Positioning lenses, mirrors, or other optical components in labs and industrial setups.</li> <li>Microscopy: Fine-tuning stages or focus mechanisms.</li> <li>Laser Systems: Aligning and stabilizing beams in optical experiments.</li> </ol> </li> </ul>"},{"location":"sections/cube/tcube/tdc001/#peripherals-examples","title":"Peripherals Examples","text":"<ul> <li>DC Servo Actuators </li> <li>Motorized Mirror Mounts </li> <li>Motorized Stages </li> </ul>"},{"location":"sections/cube/tcube/tdc001/#api-reference","title":"API Reference","text":"<p>               Bases: <code>_Cube</code></p> <p>TDC001 T-Cube Motor Controller class</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>class Tdc(_Cube):\n    \"\"\"TDC001 T-Cube Motor Controller class\"\"\"\n\n    def __init__(self, serial_dev: str):\n        super().__init__(serial_dev)\n        self.status_report_counter = 0\n\n    async def handle_message(self, msg):\n        msg_id = msg.id\n        data = msg.data\n\n        if msg_id == MGMSG.HW_DISCONNECT:\n            raise MsgError(\"Error: Please disconnect the TDC001\")\n        elif msg_id == MGMSG.HW_RESPONSE:\n            raise MsgError(\n                \"Hardware error, please disconnect \" \"and reconnect the TDC001\"\n            )\n        elif msg_id == MGMSG.HW_RICHRESPONSE:\n            (code,) = st.unpack(\"&lt;H\", data[2:4])\n            raise MsgError(\n                \"Hardware error {}: {}\".format(code, data[4:].decode(encoding=\"ascii\"))\n            )\n        elif (\n            msg_id == MGMSG.MOT_MOVE_COMPLETED\n            or msg_id == MGMSG.MOT_MOVE_STOPPED\n            or msg_id == MGMSG.MOT_GET_DCSTATUSUPDATE\n        ):\n            if self.status_report_counter == 25:\n                self.status_report_counter = 0\n                await self.send(Message(MGMSG.MOT_ACK_DCSTATUSUPDATE))\n            else:\n                self.status_report_counter += 1\n            # 'r' is a currently unused and reserved field\n            self.position, self.velocity, r, self.status = st.unpack(\n                \"&lt;LHHL\",\n                data[2:],\n            )\n\n    async def is_moving(self):\n        status_bits = await self.get_status_bits()\n        return (status_bits &amp; 0x2F0) != 0\n\n    async def set_pot_parameters(\n        self, zero_wnd, vel1, wnd1, vel2, wnd2, vel3, wnd3, vel4\n    ):\n        \"\"\"Set pot parameters.\n\n        :param zero_wnd: The deflection from the mid position (in ADC counts\n            0 to 127) before motion can start.\n        :param vel1: The velocity to move when between zero_wnd and wnd1.\n        :param wnd1: The deflection from the mid position (in ADC counts\n            zero_wnd to 127) to apply vel1.\n        :param vel2: The velocity to move when between wnd1 and wnd2.\n        :param wnd2: The deflection from the mid position (in ADC counts\n            wnd1 to 127) to apply vel2.\n        :param vel3: The velocity to move when between wnd2 and wnd3.\n        :param wnd3: The deflection from the mid position (in ADC counts\n            wnd2 to 127) to apply vel3.\n        :param vel4: The velocity to move when beyond wnd3.\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HHLHLHLHL\", 1, zero_wnd, vel1, wnd1, vel2, wnd2, vel3, wnd3, vel4\n        )\n        await self.send(Message(MGMSG.MOT_SET_POTPARAMS, data=payload))\n\n    async def get_pot_parameters(self):\n        \"\"\"Get pot parameters.\n\n        :return: An 8 int tuple containing the following values: zero_wnd,\n            vel1, wnd1, vel2, wnd2, vel3, wnd3, vel4. See\n            :py:meth:`set_pot_parameters()&lt;Tdc.set_pot_parameters&gt;` for a\n            description of each tuple element meaning.\n        :rtype: An 8 int tuple\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_POTPARAMS, [MGMSG.MOT_GET_POTPARAMS], 1\n        )\n        return st.unpack(\"&lt;HLHLHLHL\", get_msg.data[2:])\n\n    async def hub_get_bay_used(self):\n        get_msg = await self.send_request(\n            MGMSG.HUB_REQ_BAYUSED, [MGMSG.HUB_GET_BAYUSED]\n        )\n        return get_msg.param1\n\n    async def set_position_counter(self, position):\n        \"\"\"Set the \"live\" position count in the controller.\n\n        In general, this command is not normally used. Instead, the stage is\n        homed immediately after power-up; and after the homing process is\n        completed, the position counter is automatically updated to show the\n        actual position.\n\n        :param position: The new value of the position counter.\n        \"\"\"\n        payload = st.pack(\"&lt;Hl\", 1, position)\n        await self.send(Message(MGMSG.MOT_SET_POSCOUNTER, data=payload))\n\n    async def get_position_counter(self):\n        \"\"\"Get the \"live\" position count from the controller.\n\n        :return: The value of the position counter.\n        :rtype: int\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_POSCOUNTER, [MGMSG.MOT_GET_POSCOUNTER], 1\n        )\n        return st.unpack(\"&lt;l\", get_msg.data[2:])[0]\n\n    async def set_encoder_counter(self, encoder_count):\n        \"\"\"Set encoder count in the controller.\n\n        This is only applicable to stages and actuators fitted\n        with an encoder. In general this command is not normally used.\n        Instead the device is homed at power-up.\n\n        :param encoder_count: The new value of the encoder counter.\n        \"\"\"\n        payload = st.pack(\"&lt;Hl\", 1, encoder_count)\n        await self.send(Message(MGMSG.MOT_SET_ENCCOUNTER, data=payload))\n\n    async def get_encoder_counter(self):\n        \"\"\"Get encoder count from the controller.\n\n        :return: The value of the encoder counter.\n        :rtype: int\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_ENCCOUNTER, [MGMSG.MOT_GET_ENCCOUNTER], 1\n        )\n        return st.unpack(\"&lt;l\", get_msg.data[2:])[0]\n\n    async def set_velocity_parameters(self, acceleration, max_velocity):\n        \"\"\"Set the trapezoidal velocity parameter.\n\n        :param acceleration: The acceleration in encoder counts/sec/sec.\n        :param max_velocity: The maximum (final) velocity in counts/sec.\n        \"\"\"\n        payload = st.pack(\"&lt;HLLL\", 1, 0, acceleration, max_velocity)\n        await self.send(Message(MGMSG.MOT_SET_VELPARAMS, data=payload))\n\n    async def get_velocity_parameters(self):\n        \"\"\"Get the trapezoidal velocity parameters.\n\n        :return: A 2 int tuple: (acceleration, max_velocity).\n        :rtype: A 2 int tuple (int, int)\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_VELPARAMS, [MGMSG.MOT_GET_VELPARAMS], 1\n        )\n        return st.unpack(\"&lt;LL\", get_msg.data[6:])\n\n    async def set_jog_parameters(\n        self, mode, step_size, acceleration, max_velocity, stop_mode\n    ):\n        \"\"\"Set the velocity jog parameters.\n\n        :param mode: 1 for continuous jogging, 2 for single step jogging.\n        :param step_size: The jog step size in encoder counts.\n        :param acceleration: The acceleration in encoder counts/sec/sec.\n        :param max_velocity: The maximum (final) velocity in encoder\n            counts/sec.\n        :param stop_mode: 1 for immediate (abrupt) stop, 2 for profiled stop\n            (with controlled deceleration).\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HHLLLLH\",\n            1,\n            mode,\n            step_size,\n            0,\n            acceleration,\n            max_velocity,\n            stop_mode,\n        )\n        await self.send(Message(MGMSG.MOT_SET_JOGPARAMS, data=payload))\n\n    async def get_jog_parameters(self):\n        \"\"\"Get the velocity jog parameters.\n\n        :return: A 5 int tuple containing in this order: jog_mode,\n            step_size, acceleration, max_velocity, stop_mode\n        :rtype: A 5 int tuple.\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_JOGPARAMS, [MGMSG.MOT_GET_JOGPARAMS], 1\n        )\n        (jog_mode, step_size, _, acceleration, max_velocity, stop_mode) = st.unpack(\n            \"&lt;HLLLLH\", get_msg.data[2:]\n        )\n        return jog_mode, step_size, acceleration, max_velocity, stop_mode\n\n    async def set_gen_move_parameters(self, backlash_distance):\n        \"\"\"Set the backlash distance.\n\n        :param backlash_distance: The value of the backlash distance,\n            which specifies the relative distance in position counts.\n        \"\"\"\n        payload = st.pack(\"&lt;Hl\", 1, backlash_distance)\n        await self.send(Message(MGMSG.MOT_SET_GENMOVEPARAMS, data=payload))\n\n    async def get_gen_move_parameters(self):\n        \"\"\"Get the backlash distance.\n\n        :return: The value of the backlash distance.\n        :rtype: int\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_GENMOVEPARAMS, [MGMSG.MOT_GET_GENMOVEPARAMS], 1\n        )\n        return st.unpack(\"&lt;l\", get_msg.data[2:])[0]\n\n    async def set_move_relative_parameters(self, relative_distance):\n        \"\"\"Set the following relative move parameter: relative_distance.\n\n        :param relative_distance: The distance to move. This is a signed\n            integer that specifies the relative distance in position encoder\n            counts.\n        \"\"\"\n        payload = st.pack(\"&lt;Hl\", 1, relative_distance)\n        await self.send(Message(MGMSG.MOT_SET_MOVERELPARAMS, data=payload))\n\n    async def get_move_relative_parameters(self):\n        \"\"\"Get the relative distance move parameter.\n\n        :return: The relative distance move parameter.\n        :rtype: int\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_MOVERELPARAMS, [MGMSG.MOT_GET_MOVERELPARAMS], 1\n        )\n        return st.unpack(\"&lt;l\", get_msg.data[2:])[0]\n\n    async def set_move_absolute_parameters(self, absolute_position):\n        \"\"\"Set the following absolute move parameter: absolute_position.\n\n        :param absolute_position: The absolute position to move. This is a\n            signed integer that specifies the absolute move position in encoder\n            counts.\n        \"\"\"\n        payload = st.pack(\"&lt;Hl\", 1, absolute_position)\n        await self.send(Message(MGMSG.MOT_SET_MOVEABSPARAMS, data=payload))\n\n    async def get_move_absolute_parameters(self):\n        \"\"\"Get the absolute position move parameter.\n\n        :return: The absolute position to move.\n        :rtype: int\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_MOVEABSPARAMS, [MGMSG.MOT_GET_MOVEABSPARAMS], 1\n        )\n        return st.unpack(\"&lt;l\", get_msg.data[2:])[0]\n\n    async def set_home_parameters(self, home_velocity):\n        \"\"\"Set the homing velocity parameter.\n\n        :param home_velocity: Homing velocity.\n        \"\"\"\n        payload = st.pack(\"&lt;HHHLL\", 1, 0, 0, home_velocity, 0)\n        await self.send(Message(MGMSG.MOT_SET_HOMEPARAMS, data=payload))\n\n    async def get_home_parameters(self):\n        \"\"\"Get the homing velocity parameter.\n\n        :return: The homing velocity.\n        :rtype: int\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_HOMEPARAMS, [MGMSG.MOT_GET_HOMEPARAMS], 1\n        )\n        return st.unpack(\"&lt;L\", get_msg.data[6:10])[0]\n\n    async def move_home(self):\n        \"\"\"Start a home move sequence.\n\n        This call is blocking until device is homed or move is stopped.\n        \"\"\"\n        await self.send_request(\n            MGMSG.MOT_MOVE_HOME,\n            [MGMSG.MOT_MOVE_HOMED, MGMSG.MOT_MOVE_STOPPED],\n            1,\n        )\n\n    async def set_limit_switch_parameters(\n        self,\n        cw_hw_limit,\n        ccw_hw_limit,\n        cw_sw_limit=0,\n        ccw_sw_limit=0,\n        sw_limit_mode=0x1,\n    ):\n        \"\"\"Set the limit switch parameters.\n\n        :param cw_hw_limit: The operation of clockwise hardware limit switch\n            when contact is made.\n\n            0x01 Ignore switch or switch not present.\n\n            0x02 Switch makes on contact.\n\n            0x03 Switch breaks on contact.\n\n            0x04 Switch makes on contact - only used for homes (e.g. limit\n            switched rotation stages).\n\n            0x05 Switch breaks on contact - only used for homes (e.g. limit\n            switched rotations stages).\n\n            0x06 For PMD based brushless servo controllers only - uses index\n            mark for homing.\n\n            Note. Set upper bit to swap CW and CCW limit switches in code. Both\n            CWHardLimit and CCWHardLimit structure members will have the upper\n            bit set when limit switches have been physically swapped.\n        :param ccw_hw_limit: The operation of counter clockwise hardware limit\n            switch when contact is made.\n        :param cw_sw_limit: Clockwise software limit in position steps, as a\n            32 bit unsigned long. (Not applicable to TDC001 units)\n        :param ccw_sw_limit: Counter clockwise software limit in position steps\n            (scaling as for CW limit). (Not applicable to TDC001 units)\n        :param sw_limit_mode: Software limit switch mode\n\n            0x01 Ignore Limit\n\n            0x02 Stop Immediate at Limit\n\n            0x03 Profiled Stop at limit\n\n            0x80 Rotation Stage Limit (bitwise OR'd with one of the settings\n            above) (Not applicable to TDC001 units)\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HHHLLH\",\n            1,\n            cw_hw_limit,\n            ccw_hw_limit,\n            cw_sw_limit,\n            ccw_sw_limit,\n            sw_limit_mode,\n        )\n        await self.send(Message(MGMSG.MOT_SET_LIMSWITCHPARAMS, data=payload))\n\n    async def get_limit_switch_parameters(self):\n        \"\"\"Get the limit switch parameters.\n\n        :return: A 5 int tuple containing the following in order: cw_hw_limit,\n         ccw_hw_limit, cw_sw_limit, ccw_sw_limit, sw_limit_mode. Cf.\n         description in\n         :py:meth:`set_limit_switch_parameters()\n         &lt;Tdc.set_limit_switch_parameters&gt;`\n         method.\n        :rtype: A 5 int tuple.\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_LIMSWITCHPARAMS, [MGMSG.MOT_GET_LIMSWITCHPARAMS], 1\n        )\n        return st.unpack(\"&lt;HHLLH\", get_msg.data[2:])\n\n    async def move_relative_memory(self):\n        \"\"\"Start a relative move of distance in the controller's memory\n\n        The relative distance parameter used for the move will be the parameter\n        sent previously by a :py:meth:`set_move_relative_parameters()\n        &lt;Tdc.set_move_relative_parameters&gt;`\n        command.\n        \"\"\"\n        await self.send_request(\n            MGMSG.MOT_MOVE_RELATIVE,\n            [MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_STOPPED],\n            1,\n        )\n\n    async def move_relative(self, relative_distance):\n        \"\"\"Start a relative move\n\n        :param relative_distance: The distance to move in position encoder\n            counts.\n        \"\"\"\n        payload = st.pack(\"&lt;Hl\", 1, relative_distance)\n        await self.send_request(\n            MGMSG.MOT_MOVE_RELATIVE,\n            [MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_STOPPED],\n            data=payload,\n        )\n\n    async def move_absolute_memory(self):\n        \"\"\"Start an absolute move of distance in the controller's memory.\n\n        The absolute move position parameter used for the move will be the\n        parameter sent previously by a :py:meth:`set_move_absolute_parameters()\n        &lt;Tdc.set_move_absolute_parameters&gt;`\n        command.\n        \"\"\"\n        await self.send_request(\n            MGMSG.MOT_MOVE_ABSOLUTE,\n            [MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_STOPPED],\n            param1=1,\n        )\n\n    async def move_absolute(self, absolute_distance):\n        \"\"\"Start an absolute move.\n\n        :param absolute_distance: The distance to move. This is a signed\n            integer that specifies the absolute distance in position encoder\n            counts.\n        \"\"\"\n        payload = st.pack(\"&lt;Hl\", 1, absolute_distance)\n        await self.send_request(\n            MGMSG.MOT_MOVE_ABSOLUTE,\n            [MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_STOPPED],\n            data=payload,\n        )\n\n    async def move_jog(self, direction):\n        \"\"\"Start a jog move.\n\n        :param direction: The direction to jog. 1 is forward, 2 is backward.\n        \"\"\"\n        await self.send_request(\n            MGMSG.MOT_MOVE_JOG,\n            [MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_STOPPED],\n            param1=1,\n            param2=direction,\n        )\n\n    async def move_velocity(self, direction):\n        \"\"\"Start a move.\n\n        When this method is called, the motor will move continuously in the\n        specified direction using the velocity parameter set by the\n        :py:meth:`set_move_relative_parameters()\n        &lt;Tdc.set_move_relative_parameters&gt;`\n        command until a :py:meth:`move_stop()&lt;Tdc.move_stop&gt;` command (either\n        StopImmediate or StopProfiled) is called, or a limit switch is reached.\n\n        :param direction: The direction to jog: 1 to move forward, 2 to move\n            backward.\n        \"\"\"\n        await self.send(Message(MGMSG.MOT_MOVE_VELOCITY, param1=1, param2=direction))\n\n    async def move_stop(self, stop_mode):\n        \"\"\"Stop any type of motor move.\n\n        Stops any of those motor move: relative, absolute, homing or move at\n        velocity.\n\n        :param stop_mode: The stop mode defines either an immediate (abrupt)\n            or profiled stop. Set this byte to 1 to stop immediately, or to 2\n            to stop in a controlled (profiled) manner.\n        \"\"\"\n        if await self.is_moving():\n            await self.send_request(\n                MGMSG.MOT_MOVE_STOP,\n                [MGMSG.MOT_MOVE_STOPPED, MGMSG.MOT_MOVE_COMPLETED],\n                1,\n                stop_mode,\n            )\n\n    async def set_dc_pid_parameters(\n        self,\n        proportional,\n        integral,\n        differential,\n        integral_limit,\n        filter_control=0x0F,\n    ):\n        \"\"\"Set the position control loop parameters.\n\n        :param proportional: The proportional gain, values in range [0; 32767].\n        :param integral: The integral gain, values in range [0; 32767].\n        :param differential: The differential gain, values in range [0; 32767].\n        :param integral_limit: The integral limit parameter is used to cap the\n            value of the integrator to prevent runaway of the integral sum at\n            the output. Values are in range [0; 32767]. If set to 0, then\n            integration term in the PID loop is ignored.\n        :param filter_control: Identifies which of the above are applied by\n            setting the corresponding bit to 1. By default, all parameters are\n            applied, and this parameter is set to 0x0F (1111).\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HLLLLH\",\n            1,\n            proportional,\n            integral,\n            differential,\n            integral_limit,\n            filter_control,\n        )\n        await self.send(Message(MGMSG.MOT_SET_DCPIDPARAMS, data=payload))\n\n    async def get_dc_pid_parameters(self):\n        \"\"\"Get the position control loop parameters.\n\n        :return: A 5 int tuple containing in this order:\n            proportional gain, integral gain, differential gain, integral limit\n            and filter control. Cf. :py:meth:`set_dc_pid_parameters()\n            &lt;Tdc.set_dc_pid_parameters&gt;`\n            for precise description.\n        :rtype: A 5 int tuple.\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_DCPIDPARAMS, [MGMSG.MOT_GET_DCPIDPARAMS], 1\n        )\n        return st.unpack(\"&lt;LLLLH\", get_msg.data[2:])\n\n    async def set_av_modes(self, mode_bits):\n        \"\"\"Set the LED indicator modes.\n\n        The LED on the control keyboard can be configured to indicate certain\n        driver states.\n\n        :param mode_bits: Set the bit 0 will make the LED flash when the\n            'Ident' message is sent.\n            Set the bit 1 will make the LED flash when the motor reaches a\n            forward or reverse limit switch.\n            Set the bit 3 (value 8) will make the LED lit when motor is moving.\n        \"\"\"\n        payload = st.pack(\"&lt;HH\", 1, mode_bits)\n        await self.send(Message(MGMSG.MOT_SET_AVMODES, data=payload))\n\n    async def get_av_modes(self):\n        \"\"\"Get the LED indicator mode bits.\n\n        :return: The LED indicator mode bits.\n        :rtype: int\n        \"\"\"\n        get_msg = self.send_request(\n            MGMSG.MOT_REQ_AVMODES,\n            [MGMSG.MOT_GET_AVMODES],\n            1,\n        )\n        return st.unpack(\"&lt;H\", get_msg.data[2:])[0]\n\n    async def set_button_parameters(self, mode, position1, position2):\n        \"\"\"Set button parameters.\n\n        The control keypad can be used either to jog the motor, or to perform\n        moves to absolute positions. This function is used to set the front\n        panel button functionality.\n\n        :param mode: If set to 1, the buttons are used to jog the motor. Once\n            set to this mode, the move parameters for the buttons are taken\n            from the arguments of the :py:meth:`set_jog_parameters()\n            &lt;Tdc.set_jog_parameters&gt;`\n            method. If set to 2, each button can be programmed with a\n            differente position value such that the controller will move the\n            motor to that position when the specific button is pressed.\n        :param position1: The position (in encoder counts) to which the motor\n            will move when the top button is pressed.\n        :param position2: The position (in encoder counts) to which the motor\n            will move when the bottom button is pressed.\n        \"\"\"\n        payload = st.pack(\"&lt;HHllHH\", 1, mode, position1, position2, 0, 0)\n        await self.send(Message(MGMSG.MOT_SET_BUTTONPARAMS, data=payload))\n\n    async def get_button_parameters(self):\n        \"\"\"Get button parameters.\n\n        :return: A 3 int tuple containing in this order: button mode,\n            position1 and position2. Cf. :py:meth:`set_button_parameters()\n            &lt;Tdc.set_button_parameters&gt;`\n            for description.\n        :rtype: A 3 int tuple\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_BUTTONPARAMS, [MGMSG.MOT_GET_BUTTONPARAMS], 1\n        )\n        return st.unpack(\"&lt;Hll\", get_msg.data[2:12])\n\n    async def set_eeprom_parameters(self, msg_id):\n        \"\"\"Save the parameter settings for the specified message.\n\n        :param msg_id: The message ID of the message containing the parameters\n            to be saved.\n        \"\"\"\n        payload = st.pack(\"&lt;HH\", 1, msg_id)\n        await self.send(Message(MGMSG.MOT_SET_EEPROMPARAMS, data=payload))\n\n    async def get_dc_status_update(self):\n        \"\"\"Request a status update from the motor.\n\n        This can be used instead of enabling regular updates.\n\n        :return: A 3 int tuple containing in this order: position,\n            velocity, status bits.\n        :rtype: A 3 int tuple\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_DCSTATUSUPDATE, [MGMSG.MOT_GET_DCSTATUSUPDATE], 1\n        )\n        pos, vel, _, stat = st.unpack(\"&lt;LHHL\", get_msg.data[2:])\n        return pos, vel, stat\n\n    async def get_status_bits(self):\n        \"\"\"Request a cut down version of the status update with status bits.\n\n        :return: The motor status.\n        :rtype:\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_STATUSBITS, [MGMSG.MOT_GET_STATUSBITS], 1\n        )\n        return st.unpack(\"&lt;L\", get_msg.data[2:])[0]\n\n    async def suspend_end_of_move_messages(self):\n        \"\"\"Disable all unsolicited \"end of move\" messages and error messages\n        returned by the controller.\n\n        i.e., MGMSG.MOT_MOVE_STOPPED, MGMSG.MOT_MOVE_COMPLETED,\n        MGMSGS_MOT_MOVE_HOMED\n        \"\"\"\n        await self.send(Message(MGMSG.MOT_SUSPEND_ENDOFMOVEMSGS))\n\n    async def resume_end_of_move_messages(self):\n        \"\"\"Resume all unsolicited \"end of move\" messages and error messages\n        returned by the controller.\n\n        i.e., MGMSG.MOT_MOVE_STOPPED, MGMSG.MOT_MOVE_COMPLETED,\n        MGMSG.MOT_MOVE_HOMED\n\n        The command also disables the error messages that the controller sends\n        when an error condition is detected:\n        MGMSG.HW_RESPONSE,\n        MGMSG.HW_RICHRESPONSE\n        \"\"\"\n        await self.send(Message(MGMSG.MOT_RESUME_ENDOFMOVEMSGS))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_av_modes","title":"<code>get_av_modes()</code>  <code>async</code>","text":"<p>Get the LED indicator mode bits.</p> <p>:return: The LED indicator mode bits. :rtype: int</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_av_modes(self):\n    \"\"\"Get the LED indicator mode bits.\n\n    :return: The LED indicator mode bits.\n    :rtype: int\n    \"\"\"\n    get_msg = self.send_request(\n        MGMSG.MOT_REQ_AVMODES,\n        [MGMSG.MOT_GET_AVMODES],\n        1,\n    )\n    return st.unpack(\"&lt;H\", get_msg.data[2:])[0]\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_button_parameters","title":"<code>get_button_parameters()</code>  <code>async</code>","text":"<p>Get button parameters.</p> <p>:return: A 3 int tuple containing in this order: button mode,     position1 and position2. Cf. :py:meth:<code>set_button_parameters()     &lt;Tdc.set_button_parameters&gt;</code>     for description. :rtype: A 3 int tuple</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_button_parameters(self):\n    \"\"\"Get button parameters.\n\n    :return: A 3 int tuple containing in this order: button mode,\n        position1 and position2. Cf. :py:meth:`set_button_parameters()\n        &lt;Tdc.set_button_parameters&gt;`\n        for description.\n    :rtype: A 3 int tuple\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_BUTTONPARAMS, [MGMSG.MOT_GET_BUTTONPARAMS], 1\n    )\n    return st.unpack(\"&lt;Hll\", get_msg.data[2:12])\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_dc_pid_parameters","title":"<code>get_dc_pid_parameters()</code>  <code>async</code>","text":"<p>Get the position control loop parameters.</p> <p>:return: A 5 int tuple containing in this order:     proportional gain, integral gain, differential gain, integral limit     and filter control. Cf. :py:meth:<code>set_dc_pid_parameters()     &lt;Tdc.set_dc_pid_parameters&gt;</code>     for precise description. :rtype: A 5 int tuple.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_dc_pid_parameters(self):\n    \"\"\"Get the position control loop parameters.\n\n    :return: A 5 int tuple containing in this order:\n        proportional gain, integral gain, differential gain, integral limit\n        and filter control. Cf. :py:meth:`set_dc_pid_parameters()\n        &lt;Tdc.set_dc_pid_parameters&gt;`\n        for precise description.\n    :rtype: A 5 int tuple.\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_DCPIDPARAMS, [MGMSG.MOT_GET_DCPIDPARAMS], 1\n    )\n    return st.unpack(\"&lt;LLLLH\", get_msg.data[2:])\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_dc_status_update","title":"<code>get_dc_status_update()</code>  <code>async</code>","text":"<p>Request a status update from the motor.</p> <p>This can be used instead of enabling regular updates.</p> <p>:return: A 3 int tuple containing in this order: position,     velocity, status bits. :rtype: A 3 int tuple</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_dc_status_update(self):\n    \"\"\"Request a status update from the motor.\n\n    This can be used instead of enabling regular updates.\n\n    :return: A 3 int tuple containing in this order: position,\n        velocity, status bits.\n    :rtype: A 3 int tuple\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_DCSTATUSUPDATE, [MGMSG.MOT_GET_DCSTATUSUPDATE], 1\n    )\n    pos, vel, _, stat = st.unpack(\"&lt;LHHL\", get_msg.data[2:])\n    return pos, vel, stat\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_encoder_counter","title":"<code>get_encoder_counter()</code>  <code>async</code>","text":"<p>Get encoder count from the controller.</p> <p>:return: The value of the encoder counter. :rtype: int</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_encoder_counter(self):\n    \"\"\"Get encoder count from the controller.\n\n    :return: The value of the encoder counter.\n    :rtype: int\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_ENCCOUNTER, [MGMSG.MOT_GET_ENCCOUNTER], 1\n    )\n    return st.unpack(\"&lt;l\", get_msg.data[2:])[0]\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_gen_move_parameters","title":"<code>get_gen_move_parameters()</code>  <code>async</code>","text":"<p>Get the backlash distance.</p> <p>:return: The value of the backlash distance. :rtype: int</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_gen_move_parameters(self):\n    \"\"\"Get the backlash distance.\n\n    :return: The value of the backlash distance.\n    :rtype: int\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_GENMOVEPARAMS, [MGMSG.MOT_GET_GENMOVEPARAMS], 1\n    )\n    return st.unpack(\"&lt;l\", get_msg.data[2:])[0]\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_home_parameters","title":"<code>get_home_parameters()</code>  <code>async</code>","text":"<p>Get the homing velocity parameter.</p> <p>:return: The homing velocity. :rtype: int</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_home_parameters(self):\n    \"\"\"Get the homing velocity parameter.\n\n    :return: The homing velocity.\n    :rtype: int\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_HOMEPARAMS, [MGMSG.MOT_GET_HOMEPARAMS], 1\n    )\n    return st.unpack(\"&lt;L\", get_msg.data[6:10])[0]\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_jog_parameters","title":"<code>get_jog_parameters()</code>  <code>async</code>","text":"<p>Get the velocity jog parameters.</p> <p>:return: A 5 int tuple containing in this order: jog_mode,     step_size, acceleration, max_velocity, stop_mode :rtype: A 5 int tuple.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_jog_parameters(self):\n    \"\"\"Get the velocity jog parameters.\n\n    :return: A 5 int tuple containing in this order: jog_mode,\n        step_size, acceleration, max_velocity, stop_mode\n    :rtype: A 5 int tuple.\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_JOGPARAMS, [MGMSG.MOT_GET_JOGPARAMS], 1\n    )\n    (jog_mode, step_size, _, acceleration, max_velocity, stop_mode) = st.unpack(\n        \"&lt;HLLLLH\", get_msg.data[2:]\n    )\n    return jog_mode, step_size, acceleration, max_velocity, stop_mode\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_limit_switch_parameters","title":"<code>get_limit_switch_parameters()</code>  <code>async</code>","text":"<p>Get the limit switch parameters.</p> <p>:return: A 5 int tuple containing the following in order: cw_hw_limit,  ccw_hw_limit, cw_sw_limit, ccw_sw_limit, sw_limit_mode. Cf.  description in  :py:meth:<code>set_limit_switch_parameters()  &lt;Tdc.set_limit_switch_parameters&gt;</code>  method. :rtype: A 5 int tuple.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_limit_switch_parameters(self):\n    \"\"\"Get the limit switch parameters.\n\n    :return: A 5 int tuple containing the following in order: cw_hw_limit,\n     ccw_hw_limit, cw_sw_limit, ccw_sw_limit, sw_limit_mode. Cf.\n     description in\n     :py:meth:`set_limit_switch_parameters()\n     &lt;Tdc.set_limit_switch_parameters&gt;`\n     method.\n    :rtype: A 5 int tuple.\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_LIMSWITCHPARAMS, [MGMSG.MOT_GET_LIMSWITCHPARAMS], 1\n    )\n    return st.unpack(\"&lt;HHLLH\", get_msg.data[2:])\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_move_absolute_parameters","title":"<code>get_move_absolute_parameters()</code>  <code>async</code>","text":"<p>Get the absolute position move parameter.</p> <p>:return: The absolute position to move. :rtype: int</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_move_absolute_parameters(self):\n    \"\"\"Get the absolute position move parameter.\n\n    :return: The absolute position to move.\n    :rtype: int\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_MOVEABSPARAMS, [MGMSG.MOT_GET_MOVEABSPARAMS], 1\n    )\n    return st.unpack(\"&lt;l\", get_msg.data[2:])[0]\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_move_relative_parameters","title":"<code>get_move_relative_parameters()</code>  <code>async</code>","text":"<p>Get the relative distance move parameter.</p> <p>:return: The relative distance move parameter. :rtype: int</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_move_relative_parameters(self):\n    \"\"\"Get the relative distance move parameter.\n\n    :return: The relative distance move parameter.\n    :rtype: int\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_MOVERELPARAMS, [MGMSG.MOT_GET_MOVERELPARAMS], 1\n    )\n    return st.unpack(\"&lt;l\", get_msg.data[2:])[0]\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_position_counter","title":"<code>get_position_counter()</code>  <code>async</code>","text":"<p>Get the \"live\" position count from the controller.</p> <p>:return: The value of the position counter. :rtype: int</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_position_counter(self):\n    \"\"\"Get the \"live\" position count from the controller.\n\n    :return: The value of the position counter.\n    :rtype: int\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_POSCOUNTER, [MGMSG.MOT_GET_POSCOUNTER], 1\n    )\n    return st.unpack(\"&lt;l\", get_msg.data[2:])[0]\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_pot_parameters","title":"<code>get_pot_parameters()</code>  <code>async</code>","text":"<p>Get pot parameters.</p> <p>:return: An 8 int tuple containing the following values: zero_wnd,     vel1, wnd1, vel2, wnd2, vel3, wnd3, vel4. See     :py:meth:<code>set_pot_parameters()&lt;Tdc.set_pot_parameters&gt;</code> for a     description of each tuple element meaning. :rtype: An 8 int tuple</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_pot_parameters(self):\n    \"\"\"Get pot parameters.\n\n    :return: An 8 int tuple containing the following values: zero_wnd,\n        vel1, wnd1, vel2, wnd2, vel3, wnd3, vel4. See\n        :py:meth:`set_pot_parameters()&lt;Tdc.set_pot_parameters&gt;` for a\n        description of each tuple element meaning.\n    :rtype: An 8 int tuple\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_POTPARAMS, [MGMSG.MOT_GET_POTPARAMS], 1\n    )\n    return st.unpack(\"&lt;HLHLHLHL\", get_msg.data[2:])\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_status_bits","title":"<code>get_status_bits()</code>  <code>async</code>","text":"<p>Request a cut down version of the status update with status bits.</p> <p>:return: The motor status. :rtype:</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_status_bits(self):\n    \"\"\"Request a cut down version of the status update with status bits.\n\n    :return: The motor status.\n    :rtype:\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_STATUSBITS, [MGMSG.MOT_GET_STATUSBITS], 1\n    )\n    return st.unpack(\"&lt;L\", get_msg.data[2:])[0]\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.get_velocity_parameters","title":"<code>get_velocity_parameters()</code>  <code>async</code>","text":"<p>Get the trapezoidal velocity parameters.</p> <p>:return: A 2 int tuple: (acceleration, max_velocity). :rtype: A 2 int tuple (int, int)</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def get_velocity_parameters(self):\n    \"\"\"Get the trapezoidal velocity parameters.\n\n    :return: A 2 int tuple: (acceleration, max_velocity).\n    :rtype: A 2 int tuple (int, int)\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_VELPARAMS, [MGMSG.MOT_GET_VELPARAMS], 1\n    )\n    return st.unpack(\"&lt;LL\", get_msg.data[6:])\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.move_absolute","title":"<code>move_absolute(absolute_distance)</code>  <code>async</code>","text":"<p>Start an absolute move.</p> <p>:param absolute_distance: The distance to move. This is a signed     integer that specifies the absolute distance in position encoder     counts.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def move_absolute(self, absolute_distance):\n    \"\"\"Start an absolute move.\n\n    :param absolute_distance: The distance to move. This is a signed\n        integer that specifies the absolute distance in position encoder\n        counts.\n    \"\"\"\n    payload = st.pack(\"&lt;Hl\", 1, absolute_distance)\n    await self.send_request(\n        MGMSG.MOT_MOVE_ABSOLUTE,\n        [MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_STOPPED],\n        data=payload,\n    )\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.move_absolute_memory","title":"<code>move_absolute_memory()</code>  <code>async</code>","text":"<p>Start an absolute move of distance in the controller's memory.</p> <p>The absolute move position parameter used for the move will be the parameter sent previously by a :py:meth:<code>set_move_absolute_parameters() &lt;Tdc.set_move_absolute_parameters&gt;</code> command.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def move_absolute_memory(self):\n    \"\"\"Start an absolute move of distance in the controller's memory.\n\n    The absolute move position parameter used for the move will be the\n    parameter sent previously by a :py:meth:`set_move_absolute_parameters()\n    &lt;Tdc.set_move_absolute_parameters&gt;`\n    command.\n    \"\"\"\n    await self.send_request(\n        MGMSG.MOT_MOVE_ABSOLUTE,\n        [MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_STOPPED],\n        param1=1,\n    )\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.move_home","title":"<code>move_home()</code>  <code>async</code>","text":"<p>Start a home move sequence.</p> <p>This call is blocking until device is homed or move is stopped.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def move_home(self):\n    \"\"\"Start a home move sequence.\n\n    This call is blocking until device is homed or move is stopped.\n    \"\"\"\n    await self.send_request(\n        MGMSG.MOT_MOVE_HOME,\n        [MGMSG.MOT_MOVE_HOMED, MGMSG.MOT_MOVE_STOPPED],\n        1,\n    )\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.move_jog","title":"<code>move_jog(direction)</code>  <code>async</code>","text":"<p>Start a jog move.</p> <p>:param direction: The direction to jog. 1 is forward, 2 is backward.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def move_jog(self, direction):\n    \"\"\"Start a jog move.\n\n    :param direction: The direction to jog. 1 is forward, 2 is backward.\n    \"\"\"\n    await self.send_request(\n        MGMSG.MOT_MOVE_JOG,\n        [MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_STOPPED],\n        param1=1,\n        param2=direction,\n    )\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.move_relative","title":"<code>move_relative(relative_distance)</code>  <code>async</code>","text":"<p>Start a relative move</p> <p>:param relative_distance: The distance to move in position encoder     counts.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def move_relative(self, relative_distance):\n    \"\"\"Start a relative move\n\n    :param relative_distance: The distance to move in position encoder\n        counts.\n    \"\"\"\n    payload = st.pack(\"&lt;Hl\", 1, relative_distance)\n    await self.send_request(\n        MGMSG.MOT_MOVE_RELATIVE,\n        [MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_STOPPED],\n        data=payload,\n    )\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.move_relative_memory","title":"<code>move_relative_memory()</code>  <code>async</code>","text":"<p>Start a relative move of distance in the controller's memory</p> <p>The relative distance parameter used for the move will be the parameter sent previously by a :py:meth:<code>set_move_relative_parameters() &lt;Tdc.set_move_relative_parameters&gt;</code> command.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def move_relative_memory(self):\n    \"\"\"Start a relative move of distance in the controller's memory\n\n    The relative distance parameter used for the move will be the parameter\n    sent previously by a :py:meth:`set_move_relative_parameters()\n    &lt;Tdc.set_move_relative_parameters&gt;`\n    command.\n    \"\"\"\n    await self.send_request(\n        MGMSG.MOT_MOVE_RELATIVE,\n        [MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_STOPPED],\n        1,\n    )\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.move_stop","title":"<code>move_stop(stop_mode)</code>  <code>async</code>","text":"<p>Stop any type of motor move.</p> <p>Stops any of those motor move: relative, absolute, homing or move at velocity.</p> <p>:param stop_mode: The stop mode defines either an immediate (abrupt)     or profiled stop. Set this byte to 1 to stop immediately, or to 2     to stop in a controlled (profiled) manner.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def move_stop(self, stop_mode):\n    \"\"\"Stop any type of motor move.\n\n    Stops any of those motor move: relative, absolute, homing or move at\n    velocity.\n\n    :param stop_mode: The stop mode defines either an immediate (abrupt)\n        or profiled stop. Set this byte to 1 to stop immediately, or to 2\n        to stop in a controlled (profiled) manner.\n    \"\"\"\n    if await self.is_moving():\n        await self.send_request(\n            MGMSG.MOT_MOVE_STOP,\n            [MGMSG.MOT_MOVE_STOPPED, MGMSG.MOT_MOVE_COMPLETED],\n            1,\n            stop_mode,\n        )\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.move_velocity","title":"<code>move_velocity(direction)</code>  <code>async</code>","text":"<p>Start a move.</p> <p>When this method is called, the motor will move continuously in the specified direction using the velocity parameter set by the :py:meth:<code>set_move_relative_parameters() &lt;Tdc.set_move_relative_parameters&gt;</code> command until a :py:meth:<code>move_stop()&lt;Tdc.move_stop&gt;</code> command (either StopImmediate or StopProfiled) is called, or a limit switch is reached.</p> <p>:param direction: The direction to jog: 1 to move forward, 2 to move     backward.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def move_velocity(self, direction):\n    \"\"\"Start a move.\n\n    When this method is called, the motor will move continuously in the\n    specified direction using the velocity parameter set by the\n    :py:meth:`set_move_relative_parameters()\n    &lt;Tdc.set_move_relative_parameters&gt;`\n    command until a :py:meth:`move_stop()&lt;Tdc.move_stop&gt;` command (either\n    StopImmediate or StopProfiled) is called, or a limit switch is reached.\n\n    :param direction: The direction to jog: 1 to move forward, 2 to move\n        backward.\n    \"\"\"\n    await self.send(Message(MGMSG.MOT_MOVE_VELOCITY, param1=1, param2=direction))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.resume_end_of_move_messages","title":"<code>resume_end_of_move_messages()</code>  <code>async</code>","text":"<p>Resume all unsolicited \"end of move\" messages and error messages returned by the controller.</p> <p>i.e., MGMSG.MOT_MOVE_STOPPED, MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_HOMED</p> <p>The command also disables the error messages that the controller sends when an error condition is detected: MGMSG.HW_RESPONSE, MGMSG.HW_RICHRESPONSE</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def resume_end_of_move_messages(self):\n    \"\"\"Resume all unsolicited \"end of move\" messages and error messages\n    returned by the controller.\n\n    i.e., MGMSG.MOT_MOVE_STOPPED, MGMSG.MOT_MOVE_COMPLETED,\n    MGMSG.MOT_MOVE_HOMED\n\n    The command also disables the error messages that the controller sends\n    when an error condition is detected:\n    MGMSG.HW_RESPONSE,\n    MGMSG.HW_RICHRESPONSE\n    \"\"\"\n    await self.send(Message(MGMSG.MOT_RESUME_ENDOFMOVEMSGS))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_av_modes","title":"<code>set_av_modes(mode_bits)</code>  <code>async</code>","text":"<p>Set the LED indicator modes.</p> <p>The LED on the control keyboard can be configured to indicate certain driver states.</p> <p>:param mode_bits: Set the bit 0 will make the LED flash when the     'Ident' message is sent.     Set the bit 1 will make the LED flash when the motor reaches a     forward or reverse limit switch.     Set the bit 3 (value 8) will make the LED lit when motor is moving.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_av_modes(self, mode_bits):\n    \"\"\"Set the LED indicator modes.\n\n    The LED on the control keyboard can be configured to indicate certain\n    driver states.\n\n    :param mode_bits: Set the bit 0 will make the LED flash when the\n        'Ident' message is sent.\n        Set the bit 1 will make the LED flash when the motor reaches a\n        forward or reverse limit switch.\n        Set the bit 3 (value 8) will make the LED lit when motor is moving.\n    \"\"\"\n    payload = st.pack(\"&lt;HH\", 1, mode_bits)\n    await self.send(Message(MGMSG.MOT_SET_AVMODES, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_button_parameters","title":"<code>set_button_parameters(mode, position1, position2)</code>  <code>async</code>","text":"<p>Set button parameters.</p> <p>The control keypad can be used either to jog the motor, or to perform moves to absolute positions. This function is used to set the front panel button functionality.</p> <p>:param mode: If set to 1, the buttons are used to jog the motor. Once     set to this mode, the move parameters for the buttons are taken     from the arguments of the :py:meth:<code>set_jog_parameters()     &lt;Tdc.set_jog_parameters&gt;</code>     method. If set to 2, each button can be programmed with a     differente position value such that the controller will move the     motor to that position when the specific button is pressed. :param position1: The position (in encoder counts) to which the motor     will move when the top button is pressed. :param position2: The position (in encoder counts) to which the motor     will move when the bottom button is pressed.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_button_parameters(self, mode, position1, position2):\n    \"\"\"Set button parameters.\n\n    The control keypad can be used either to jog the motor, or to perform\n    moves to absolute positions. This function is used to set the front\n    panel button functionality.\n\n    :param mode: If set to 1, the buttons are used to jog the motor. Once\n        set to this mode, the move parameters for the buttons are taken\n        from the arguments of the :py:meth:`set_jog_parameters()\n        &lt;Tdc.set_jog_parameters&gt;`\n        method. If set to 2, each button can be programmed with a\n        differente position value such that the controller will move the\n        motor to that position when the specific button is pressed.\n    :param position1: The position (in encoder counts) to which the motor\n        will move when the top button is pressed.\n    :param position2: The position (in encoder counts) to which the motor\n        will move when the bottom button is pressed.\n    \"\"\"\n    payload = st.pack(\"&lt;HHllHH\", 1, mode, position1, position2, 0, 0)\n    await self.send(Message(MGMSG.MOT_SET_BUTTONPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_dc_pid_parameters","title":"<code>set_dc_pid_parameters(proportional, integral, differential, integral_limit, filter_control=15)</code>  <code>async</code>","text":"<p>Set the position control loop parameters.</p> <p>:param proportional: The proportional gain, values in range [0; 32767]. :param integral: The integral gain, values in range [0; 32767]. :param differential: The differential gain, values in range [0; 32767]. :param integral_limit: The integral limit parameter is used to cap the     value of the integrator to prevent runaway of the integral sum at     the output. Values are in range [0; 32767]. If set to 0, then     integration term in the PID loop is ignored. :param filter_control: Identifies which of the above are applied by     setting the corresponding bit to 1. By default, all parameters are     applied, and this parameter is set to 0x0F (1111).</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_dc_pid_parameters(\n    self,\n    proportional,\n    integral,\n    differential,\n    integral_limit,\n    filter_control=0x0F,\n):\n    \"\"\"Set the position control loop parameters.\n\n    :param proportional: The proportional gain, values in range [0; 32767].\n    :param integral: The integral gain, values in range [0; 32767].\n    :param differential: The differential gain, values in range [0; 32767].\n    :param integral_limit: The integral limit parameter is used to cap the\n        value of the integrator to prevent runaway of the integral sum at\n        the output. Values are in range [0; 32767]. If set to 0, then\n        integration term in the PID loop is ignored.\n    :param filter_control: Identifies which of the above are applied by\n        setting the corresponding bit to 1. By default, all parameters are\n        applied, and this parameter is set to 0x0F (1111).\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HLLLLH\",\n        1,\n        proportional,\n        integral,\n        differential,\n        integral_limit,\n        filter_control,\n    )\n    await self.send(Message(MGMSG.MOT_SET_DCPIDPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_eeprom_parameters","title":"<code>set_eeprom_parameters(msg_id)</code>  <code>async</code>","text":"<p>Save the parameter settings for the specified message.</p> <p>:param msg_id: The message ID of the message containing the parameters     to be saved.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_eeprom_parameters(self, msg_id):\n    \"\"\"Save the parameter settings for the specified message.\n\n    :param msg_id: The message ID of the message containing the parameters\n        to be saved.\n    \"\"\"\n    payload = st.pack(\"&lt;HH\", 1, msg_id)\n    await self.send(Message(MGMSG.MOT_SET_EEPROMPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_encoder_counter","title":"<code>set_encoder_counter(encoder_count)</code>  <code>async</code>","text":"<p>Set encoder count in the controller.</p> <p>This is only applicable to stages and actuators fitted with an encoder. In general this command is not normally used. Instead the device is homed at power-up.</p> <p>:param encoder_count: The new value of the encoder counter.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_encoder_counter(self, encoder_count):\n    \"\"\"Set encoder count in the controller.\n\n    This is only applicable to stages and actuators fitted\n    with an encoder. In general this command is not normally used.\n    Instead the device is homed at power-up.\n\n    :param encoder_count: The new value of the encoder counter.\n    \"\"\"\n    payload = st.pack(\"&lt;Hl\", 1, encoder_count)\n    await self.send(Message(MGMSG.MOT_SET_ENCCOUNTER, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_gen_move_parameters","title":"<code>set_gen_move_parameters(backlash_distance)</code>  <code>async</code>","text":"<p>Set the backlash distance.</p> <p>:param backlash_distance: The value of the backlash distance,     which specifies the relative distance in position counts.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_gen_move_parameters(self, backlash_distance):\n    \"\"\"Set the backlash distance.\n\n    :param backlash_distance: The value of the backlash distance,\n        which specifies the relative distance in position counts.\n    \"\"\"\n    payload = st.pack(\"&lt;Hl\", 1, backlash_distance)\n    await self.send(Message(MGMSG.MOT_SET_GENMOVEPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_home_parameters","title":"<code>set_home_parameters(home_velocity)</code>  <code>async</code>","text":"<p>Set the homing velocity parameter.</p> <p>:param home_velocity: Homing velocity.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_home_parameters(self, home_velocity):\n    \"\"\"Set the homing velocity parameter.\n\n    :param home_velocity: Homing velocity.\n    \"\"\"\n    payload = st.pack(\"&lt;HHHLL\", 1, 0, 0, home_velocity, 0)\n    await self.send(Message(MGMSG.MOT_SET_HOMEPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_jog_parameters","title":"<code>set_jog_parameters(mode, step_size, acceleration, max_velocity, stop_mode)</code>  <code>async</code>","text":"<p>Set the velocity jog parameters.</p> <p>:param mode: 1 for continuous jogging, 2 for single step jogging. :param step_size: The jog step size in encoder counts. :param acceleration: The acceleration in encoder counts/sec/sec. :param max_velocity: The maximum (final) velocity in encoder     counts/sec. :param stop_mode: 1 for immediate (abrupt) stop, 2 for profiled stop     (with controlled deceleration).</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_jog_parameters(\n    self, mode, step_size, acceleration, max_velocity, stop_mode\n):\n    \"\"\"Set the velocity jog parameters.\n\n    :param mode: 1 for continuous jogging, 2 for single step jogging.\n    :param step_size: The jog step size in encoder counts.\n    :param acceleration: The acceleration in encoder counts/sec/sec.\n    :param max_velocity: The maximum (final) velocity in encoder\n        counts/sec.\n    :param stop_mode: 1 for immediate (abrupt) stop, 2 for profiled stop\n        (with controlled deceleration).\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HHLLLLH\",\n        1,\n        mode,\n        step_size,\n        0,\n        acceleration,\n        max_velocity,\n        stop_mode,\n    )\n    await self.send(Message(MGMSG.MOT_SET_JOGPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_limit_switch_parameters","title":"<code>set_limit_switch_parameters(cw_hw_limit, ccw_hw_limit, cw_sw_limit=0, ccw_sw_limit=0, sw_limit_mode=1)</code>  <code>async</code>","text":"<p>Set the limit switch parameters.</p> <p>:param cw_hw_limit: The operation of clockwise hardware limit switch     when contact is made.</p> <pre><code>0x01 Ignore switch or switch not present.\n\n0x02 Switch makes on contact.\n\n0x03 Switch breaks on contact.\n\n0x04 Switch makes on contact - only used for homes (e.g. limit\nswitched rotation stages).\n\n0x05 Switch breaks on contact - only used for homes (e.g. limit\nswitched rotations stages).\n\n0x06 For PMD based brushless servo controllers only - uses index\nmark for homing.\n\nNote. Set upper bit to swap CW and CCW limit switches in code. Both\nCWHardLimit and CCWHardLimit structure members will have the upper\nbit set when limit switches have been physically swapped.\n</code></pre> <p>:param ccw_hw_limit: The operation of counter clockwise hardware limit     switch when contact is made. :param cw_sw_limit: Clockwise software limit in position steps, as a     32 bit unsigned long. (Not applicable to TDC001 units) :param ccw_sw_limit: Counter clockwise software limit in position steps     (scaling as for CW limit). (Not applicable to TDC001 units) :param sw_limit_mode: Software limit switch mode</p> <pre><code>0x01 Ignore Limit\n\n0x02 Stop Immediate at Limit\n\n0x03 Profiled Stop at limit\n\n0x80 Rotation Stage Limit (bitwise OR'd with one of the settings\nabove) (Not applicable to TDC001 units)\n</code></pre> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_limit_switch_parameters(\n    self,\n    cw_hw_limit,\n    ccw_hw_limit,\n    cw_sw_limit=0,\n    ccw_sw_limit=0,\n    sw_limit_mode=0x1,\n):\n    \"\"\"Set the limit switch parameters.\n\n    :param cw_hw_limit: The operation of clockwise hardware limit switch\n        when contact is made.\n\n        0x01 Ignore switch or switch not present.\n\n        0x02 Switch makes on contact.\n\n        0x03 Switch breaks on contact.\n\n        0x04 Switch makes on contact - only used for homes (e.g. limit\n        switched rotation stages).\n\n        0x05 Switch breaks on contact - only used for homes (e.g. limit\n        switched rotations stages).\n\n        0x06 For PMD based brushless servo controllers only - uses index\n        mark for homing.\n\n        Note. Set upper bit to swap CW and CCW limit switches in code. Both\n        CWHardLimit and CCWHardLimit structure members will have the upper\n        bit set when limit switches have been physically swapped.\n    :param ccw_hw_limit: The operation of counter clockwise hardware limit\n        switch when contact is made.\n    :param cw_sw_limit: Clockwise software limit in position steps, as a\n        32 bit unsigned long. (Not applicable to TDC001 units)\n    :param ccw_sw_limit: Counter clockwise software limit in position steps\n        (scaling as for CW limit). (Not applicable to TDC001 units)\n    :param sw_limit_mode: Software limit switch mode\n\n        0x01 Ignore Limit\n\n        0x02 Stop Immediate at Limit\n\n        0x03 Profiled Stop at limit\n\n        0x80 Rotation Stage Limit (bitwise OR'd with one of the settings\n        above) (Not applicable to TDC001 units)\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HHHLLH\",\n        1,\n        cw_hw_limit,\n        ccw_hw_limit,\n        cw_sw_limit,\n        ccw_sw_limit,\n        sw_limit_mode,\n    )\n    await self.send(Message(MGMSG.MOT_SET_LIMSWITCHPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_move_absolute_parameters","title":"<code>set_move_absolute_parameters(absolute_position)</code>  <code>async</code>","text":"<p>Set the following absolute move parameter: absolute_position.</p> <p>:param absolute_position: The absolute position to move. This is a     signed integer that specifies the absolute move position in encoder     counts.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_move_absolute_parameters(self, absolute_position):\n    \"\"\"Set the following absolute move parameter: absolute_position.\n\n    :param absolute_position: The absolute position to move. This is a\n        signed integer that specifies the absolute move position in encoder\n        counts.\n    \"\"\"\n    payload = st.pack(\"&lt;Hl\", 1, absolute_position)\n    await self.send(Message(MGMSG.MOT_SET_MOVEABSPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_move_relative_parameters","title":"<code>set_move_relative_parameters(relative_distance)</code>  <code>async</code>","text":"<p>Set the following relative move parameter: relative_distance.</p> <p>:param relative_distance: The distance to move. This is a signed     integer that specifies the relative distance in position encoder     counts.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_move_relative_parameters(self, relative_distance):\n    \"\"\"Set the following relative move parameter: relative_distance.\n\n    :param relative_distance: The distance to move. This is a signed\n        integer that specifies the relative distance in position encoder\n        counts.\n    \"\"\"\n    payload = st.pack(\"&lt;Hl\", 1, relative_distance)\n    await self.send(Message(MGMSG.MOT_SET_MOVERELPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_position_counter","title":"<code>set_position_counter(position)</code>  <code>async</code>","text":"<p>Set the \"live\" position count in the controller.</p> <p>In general, this command is not normally used. Instead, the stage is homed immediately after power-up; and after the homing process is completed, the position counter is automatically updated to show the actual position.</p> <p>:param position: The new value of the position counter.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_position_counter(self, position):\n    \"\"\"Set the \"live\" position count in the controller.\n\n    In general, this command is not normally used. Instead, the stage is\n    homed immediately after power-up; and after the homing process is\n    completed, the position counter is automatically updated to show the\n    actual position.\n\n    :param position: The new value of the position counter.\n    \"\"\"\n    payload = st.pack(\"&lt;Hl\", 1, position)\n    await self.send(Message(MGMSG.MOT_SET_POSCOUNTER, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_pot_parameters","title":"<code>set_pot_parameters(zero_wnd, vel1, wnd1, vel2, wnd2, vel3, wnd3, vel4)</code>  <code>async</code>","text":"<p>Set pot parameters.</p> <p>:param zero_wnd: The deflection from the mid position (in ADC counts     0 to 127) before motion can start. :param vel1: The velocity to move when between zero_wnd and wnd1. :param wnd1: The deflection from the mid position (in ADC counts     zero_wnd to 127) to apply vel1. :param vel2: The velocity to move when between wnd1 and wnd2. :param wnd2: The deflection from the mid position (in ADC counts     wnd1 to 127) to apply vel2. :param vel3: The velocity to move when between wnd2 and wnd3. :param wnd3: The deflection from the mid position (in ADC counts     wnd2 to 127) to apply vel3. :param vel4: The velocity to move when beyond wnd3.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_pot_parameters(\n    self, zero_wnd, vel1, wnd1, vel2, wnd2, vel3, wnd3, vel4\n):\n    \"\"\"Set pot parameters.\n\n    :param zero_wnd: The deflection from the mid position (in ADC counts\n        0 to 127) before motion can start.\n    :param vel1: The velocity to move when between zero_wnd and wnd1.\n    :param wnd1: The deflection from the mid position (in ADC counts\n        zero_wnd to 127) to apply vel1.\n    :param vel2: The velocity to move when between wnd1 and wnd2.\n    :param wnd2: The deflection from the mid position (in ADC counts\n        wnd1 to 127) to apply vel2.\n    :param vel3: The velocity to move when between wnd2 and wnd3.\n    :param wnd3: The deflection from the mid position (in ADC counts\n        wnd2 to 127) to apply vel3.\n    :param vel4: The velocity to move when beyond wnd3.\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HHLHLHLHL\", 1, zero_wnd, vel1, wnd1, vel2, wnd2, vel3, wnd3, vel4\n    )\n    await self.send(Message(MGMSG.MOT_SET_POTPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.set_velocity_parameters","title":"<code>set_velocity_parameters(acceleration, max_velocity)</code>  <code>async</code>","text":"<p>Set the trapezoidal velocity parameter.</p> <p>:param acceleration: The acceleration in encoder counts/sec/sec. :param max_velocity: The maximum (final) velocity in counts/sec.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def set_velocity_parameters(self, acceleration, max_velocity):\n    \"\"\"Set the trapezoidal velocity parameter.\n\n    :param acceleration: The acceleration in encoder counts/sec/sec.\n    :param max_velocity: The maximum (final) velocity in counts/sec.\n    \"\"\"\n    payload = st.pack(\"&lt;HLLL\", 1, 0, acceleration, max_velocity)\n    await self.send(Message(MGMSG.MOT_SET_VELPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tdc001/#thorlabs_cube.driver.tcube.tdc.Tdc.suspend_end_of_move_messages","title":"<code>suspend_end_of_move_messages()</code>  <code>async</code>","text":"<p>Disable all unsolicited \"end of move\" messages and error messages returned by the controller.</p> <p>i.e., MGMSG.MOT_MOVE_STOPPED, MGMSG.MOT_MOVE_COMPLETED, MGMSGS_MOT_MOVE_HOMED</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tdc.py</code> <pre><code>async def suspend_end_of_move_messages(self):\n    \"\"\"Disable all unsolicited \"end of move\" messages and error messages\n    returned by the controller.\n\n    i.e., MGMSG.MOT_MOVE_STOPPED, MGMSG.MOT_MOVE_COMPLETED,\n    MGMSGS_MOT_MOVE_HOMED\n    \"\"\"\n    await self.send(Message(MGMSG.MOT_SUSPEND_ENDOFMOVEMSGS))\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/","title":"TPA101","text":""},{"location":"sections/cube/tcube/tpa101/#controller-description","title":"Controller Description","text":"<p>The TPA101 is a compact single-channel T-Cube controller from Thorlabs designed for precise automatic alignment of optical components using Position-Sensitive Detectors (PSDs). It is typically used in optical systems requiring high-speed, real-time feedback-based alignment. The TPA101 is compatible with Thorlabs\u2019 auto-alignment peripherals and features USB connectivity for computer control via Thorlabs\u2019 Kinesis Software or QuantumION's Thorlabs Cube Repository.</p>"},{"location":"sections/cube/tcube/tpa101/#controller-use-cases","title":"Controller Use-Cases","text":"<ul> <li>TPA101 is used in applications where precise optical alignment is essential, such as:<ol> <li>Beam Stabilization: Maintaining optical beam position stability over time.</li> <li>Optical Alignment Automation: Real-time alignment of lenses, mirrors, and other optical elements.</li> <li>Laser Systems: Dynamic alignment of laser beams for maximum throughput and precision.</li> </ol> </li> </ul>"},{"location":"sections/cube/tcube/tpa101/#peripherals-examples","title":"Peripherals Examples","text":"<ul> <li>Position-Sensitive Detectors </li> <li>Motorized Mirror Mounts </li> <li>Auto-Aligning Modules</li> </ul>"},{"location":"sections/cube/tcube/tpa101/#api-reference","title":"API Reference","text":"<p>               Bases: <code>_Cube</code></p> <p>TPA101 Position Sensing Detector driver implementation.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>class Tpa(_Cube):\n    \"\"\"TPA101 Position Sensing Detector driver implementation.\"\"\"\n\n    def __init__(self, serial_dev: str) -&gt; None:\n        \"\"\"Initialize the TPA101 driver.\n\n        :param serial_dev: Serial device identifier.\n        \"\"\"\n        super().__init__(serial_dev)\n        self.loop_params = None\n        self.status_report_counter = 0\n\n    async def handle_message(self, msg: Message) -&gt; None:\n        \"\"\"Handle incoming messages from the TPA101 device.\n\n        :param msg: Message object received from the device.\n        \"\"\"\n        msg_id: MGMSG = msg.id\n        data: bytes = msg.data\n\n        if msg_id == MGMSG.HW_DISCONNECT:\n            raise MsgError(\"Error: Please disconnect the TPA101\")\n\n        elif msg_id == MGMSG.HW_RESPONSE:\n            raise MsgError(\"Hardware error, please disconnect and reconnect the TPA101\")\n\n        elif msg_id == MGMSG.QUAD_GET_STATUSUPDATE:\n            x_diff, y_diff, sum_val, x_pos, y_pos, status_bits = st.unpack(\n                \"&lt;hhIhhI\", data[6:20]\n            )\n\n            # Update internal state variables with the extracted values\n            self.x_diff = x_diff\n            self.y_diff = y_diff\n            self.sum_val = sum_val\n            self.x_pos = x_pos\n            self.y_pos = y_pos\n            self.status_bits = status_bits\n\n            if self.status_report_counter == 25:\n                self.status_report_counter = 0\n                await self.send(Message(MGMSG.QUAD_ACK_STATUSUPDATE))\n            else:\n                self.status_report_counter += 1\n\n    async def set_loop_params(self, p_gain: int, i_gain: int, d_gain: int) -&gt; None:\n        \"\"\"Set proportional, integral, and differential feedback loop constants.\n\n        :param p_gain: Proportional gain value.\n        :param i_gain: Integral gain value.\n        :param d_gain: Differential gain value.\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HHHH\", QUADMSG.QUAD_LOOP_PARAMS_SUB_ID.value, p_gain, i_gain, d_gain\n        )\n        await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n\n    async def get_loop_params(self) -&gt; tuple[int, int, int]:\n        \"\"\"Get proportional, integral, and differential feedback loop constants.\n\n        :return: A tuple containing p_gain, i_gain, and d_gain values.\n        \"\"\"\n\n        get_msg = await self.send_request(\n            MGMSG.QUAD_REQ_PARAMS,\n            [MGMSG.QUAD_GET_PARAMS],\n            param1=QUADMSG.QUAD_LOOP_PARAMS_SUB_ID.value,\n        )\n        return st.unpack(\"&lt;HHHH\", get_msg.data)[1:]\n\n    async def set_quad_oper_mode(self, mode: int) -&gt; None:\n        \"\"\"Set the operating mode of the unit.\n\n        :param mode: 1 for Monitor Mode, 2 for Open Loop, 3 for Closed Loop.\n        \"\"\"\n\n        payload = st.pack(\"&lt;HH\", QUADMSG.QUAD_OPER_MODE_SUB_ID.value, mode)\n        await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n\n    async def get_quad_oper_mode(self) -&gt; int:\n        \"\"\"Get the operating mode of the unit.\n\n        :return: The current operating mode of the unit.\n        \"\"\"\n\n        get_msg = await self.send_request(\n            MGMSG.QUAD_REQ_PARAMS,\n            [MGMSG.QUAD_GET_PARAMS],\n            param1=QUADMSG.QUAD_OPER_MODE_SUB_ID.value,\n        )\n        return st.unpack(\"&lt;HH\", get_msg.data)[1]\n\n    async def set_quad_position_demand_params(\n        self,\n        x_pos_min: int,\n        x_pos_max: int,\n        y_pos_min: int,\n        y_pos_max: int,\n        low_volt_output_route: int,\n        open_loop_pos_demands: int,\n        x_pos_demand_feedback_sense: float,\n        y_pos_demand_feedback_sense: float,\n    ) -&gt; None:\n        \"\"\"Set position demand parameters for the quad system.\n\n        :param x_pos_min: Minimum X-axis position demand.\n        :param x_pos_max: Maximum X-axis position demand.\n        :param y_pos_min: Minimum Y-axis position demand.\n        :param y_pos_max: Maximum Y-axis position demand.\n        :param low_volt_output_route: LV output signal routing\n        :param open_loop_pos_demands: Open loop position demands configuration\n        :param x_pos_demand_feedback_sense: Signal sense and gain for X-axis output\n        :param y_pos_demand_feedback_sense: Signal sense and gain for Y-axis output\n        \"\"\"\n        payload = st.pack(\n            \"&lt;hhhhhhhhh\",\n            QUADMSG.QUAD_POSITION_DEMAND_PARAMS_SUB_ID.value,\n            x_pos_min,\n            x_pos_max,\n            y_pos_min,\n            y_pos_max,\n            low_volt_output_route,\n            open_loop_pos_demands,\n            x_pos_demand_feedback_sense,\n            y_pos_demand_feedback_sense,\n        )\n        await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n\n    async def get_quad_position_demand_params(self) -&gt; tuple[int, int, int, int]:\n        \"\"\"Get position demand parameters for the quad system.\n\n        :return: A tuple containing x_pos_min, x_pos_max, y_pos_min, and y_pos_max.\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.QUAD_REQ_PARAMS,\n            [MGMSG.QUAD_GET_PARAMS],\n            param1=QUADMSG.QUAD_POSITION_DEMAND_PARAMS_SUB_ID.value,\n        )\n        return st.unpack(\"&lt;hhhhhhhhh\", get_msg.data)[1:]\n\n    async def get_quad_status_bits(self) -&gt; int:\n        \"\"\"Get the status bits of the control unit.\n\n        :return: Status bits of the control unit.\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.QUAD_REQ_PARAMS,\n            [MGMSG.QUAD_GET_PARAMS],\n            param1=QUADMSG.QUAD_STATUS_BITS_SUB_ID.value,\n        )\n        return st.unpack(\"&lt;HI\", get_msg.data)[1]\n\n    async def get_quad_readings(self) -&gt; tuple[int, int, int, int, int]:\n        \"\"\"Get the status bits of the quad readings.\n\n        :return: Status bits of the quad reading.\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.QUAD_REQ_PARAMS,\n            [MGMSG.QUAD_GET_PARAMS],\n            param1=QUADMSG.QUAD_READINGS_SUB_ID.value,\n        )\n        return st.unpack(\"HHHHHH\", get_msg.data)[1:]\n\n    async def set_quad_display_settings(\n        self, disp_intensity: int, disp_mode: int, disp_dim_timeout: int\n    ) -&gt; None:\n        \"\"\"Set the display settings for the quad system.\n\n        :param disp_intensity: Display intensity (0-255).\n        :param disp_mode: Display mode (1 for Difference, 2 for Position).\n        :param disp_dim_timeout: Dim timeout value as per documentation.\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HHHH\",\n            QUADMSG.QUAD_DISP_SETTINGS_SUB_ID.value,\n            disp_intensity,\n            disp_mode,\n            disp_dim_timeout,\n        )\n        await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n\n    async def get_quad_display_settings(self) -&gt; tuple[int, int, int]:\n        \"\"\"Get the display settings for the quad system.\n\n        :return: A tuple containing disp_intensity, disp_mode, and disp_dim_timeout.\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.QUAD_REQ_PARAMS,\n            [MGMSG.QUAD_GET_PARAMS],\n            param1=QUADMSG.QUAD_DISP_SETTINGS_SUB_ID.value,\n        )\n        return st.unpack(\"&lt;HHHH\", get_msg.data)[1:]\n\n    async def set_quad_position_outputs(self, x_pos: int, y_pos: int) -&gt; None:\n        \"\"\"Set the X and Y position outputs.\n\n        :param x_pos: X-axis position output value (-32768 to 32767).\n        :param y_pos: Y-axis position output value (-32768 to 32767).\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HHH\", QUADMSG.QUAD_POSITION_OUTPUTS_SUB_ID.value, x_pos, y_pos\n        )\n        await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n\n    async def get_quad_position_outputs(self) -&gt; tuple[int, int]:\n        \"\"\"Get the X and Y position outputs.\n\n        :return: A tuple containing x_pos and y_pos.\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.QUAD_REQ_PARAMS,\n            [MGMSG.QUAD_GET_PARAMS],\n            param1=QUADMSG.QUAD_POSITION_OUTPUTS_SUB_ID.value,\n        )\n        return st.unpack(\"&lt;Hhh\", get_msg.data)[1:]\n\n    async def set_quad_loop_params_two(\n        self,\n        p_gain: float,\n        i_gain: float,\n        d_gain: float,\n        d_cutoff_freq: float,\n        notch_freq: float,\n        filter_q: float,\n        notch_on: int,\n        deriv_filter_on: int,\n    ) -&gt; None:\n        \"\"\"Set the extended loop parameters for the quad system.\n\n        :param p_gain: Proportional gain value.\n        :param i_gain: Integral gain value.\n        :param d_gain: Differential gain value.\n        :param d_cutoff_freq: Differential cutoff frequency.\n        :param notch_freq: Notch filter frequency.\n        :param filter_q: Filter quality factor.\n        :param notch_on: Notch filter on/off flag.\n        :param deriv_filter_on: Derivative filter on/off flag.\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HFFFFFFHH\",\n            QUADMSG.QUAD_LOOP_PARAMS_TWO_SUB_ID.value,\n            p_gain,\n            i_gain,\n            d_gain,\n            d_cutoff_freq,\n            notch_freq,\n            filter_q,\n            notch_on,\n            deriv_filter_on,\n        )\n        await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n\n    async def get_quad_loop_params_two(\n        self,\n    ) -&gt; tuple[float, float, float, float, float, float, int, int]:\n        \"\"\"Get the extended loop parameters for the quad system.\n\n        :return: A tuple containing p_gain, i_gain, d_gain, d_cutoff_freq,\n        notch_freq, filter_q, notch_on, deriv_filter_on.\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.QUAD_REQ_PARAMS,\n            [MGMSG.QUAD_GET_PARAMS],\n            param1=QUADMSG.QUAD_LOOP_PARAMS_TWO_SUB_ID.value,\n        )\n        return st.unpack(\"&lt;HFFFFFFHH\", get_msg.data)\n\n    async def set_eeprom_params(self, msg_id: int) -&gt; None:\n        \"\"\"Save the parameter settings for the specified message.\n\n        :param msg_id: The message ID of the message containing the parameters to be saved.\n        \"\"\"\n        payload = st.pack(\"&lt;H\", msg_id)\n        await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.__init__","title":"<code>__init__(serial_dev)</code>","text":"<p>Initialize the TPA101 driver.</p> <p>:param serial_dev: Serial device identifier.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>def __init__(self, serial_dev: str) -&gt; None:\n    \"\"\"Initialize the TPA101 driver.\n\n    :param serial_dev: Serial device identifier.\n    \"\"\"\n    super().__init__(serial_dev)\n    self.loop_params = None\n    self.status_report_counter = 0\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.get_loop_params","title":"<code>get_loop_params()</code>  <code>async</code>","text":"<p>Get proportional, integral, and differential feedback loop constants.</p> <p>:return: A tuple containing p_gain, i_gain, and d_gain values.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def get_loop_params(self) -&gt; tuple[int, int, int]:\n    \"\"\"Get proportional, integral, and differential feedback loop constants.\n\n    :return: A tuple containing p_gain, i_gain, and d_gain values.\n    \"\"\"\n\n    get_msg = await self.send_request(\n        MGMSG.QUAD_REQ_PARAMS,\n        [MGMSG.QUAD_GET_PARAMS],\n        param1=QUADMSG.QUAD_LOOP_PARAMS_SUB_ID.value,\n    )\n    return st.unpack(\"&lt;HHHH\", get_msg.data)[1:]\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.get_quad_display_settings","title":"<code>get_quad_display_settings()</code>  <code>async</code>","text":"<p>Get the display settings for the quad system.</p> <p>:return: A tuple containing disp_intensity, disp_mode, and disp_dim_timeout.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def get_quad_display_settings(self) -&gt; tuple[int, int, int]:\n    \"\"\"Get the display settings for the quad system.\n\n    :return: A tuple containing disp_intensity, disp_mode, and disp_dim_timeout.\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.QUAD_REQ_PARAMS,\n        [MGMSG.QUAD_GET_PARAMS],\n        param1=QUADMSG.QUAD_DISP_SETTINGS_SUB_ID.value,\n    )\n    return st.unpack(\"&lt;HHHH\", get_msg.data)[1:]\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.get_quad_loop_params_two","title":"<code>get_quad_loop_params_two()</code>  <code>async</code>","text":"<p>Get the extended loop parameters for the quad system.</p> <p>:return: A tuple containing p_gain, i_gain, d_gain, d_cutoff_freq, notch_freq, filter_q, notch_on, deriv_filter_on.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def get_quad_loop_params_two(\n    self,\n) -&gt; tuple[float, float, float, float, float, float, int, int]:\n    \"\"\"Get the extended loop parameters for the quad system.\n\n    :return: A tuple containing p_gain, i_gain, d_gain, d_cutoff_freq,\n    notch_freq, filter_q, notch_on, deriv_filter_on.\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.QUAD_REQ_PARAMS,\n        [MGMSG.QUAD_GET_PARAMS],\n        param1=QUADMSG.QUAD_LOOP_PARAMS_TWO_SUB_ID.value,\n    )\n    return st.unpack(\"&lt;HFFFFFFHH\", get_msg.data)\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.get_quad_oper_mode","title":"<code>get_quad_oper_mode()</code>  <code>async</code>","text":"<p>Get the operating mode of the unit.</p> <p>:return: The current operating mode of the unit.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def get_quad_oper_mode(self) -&gt; int:\n    \"\"\"Get the operating mode of the unit.\n\n    :return: The current operating mode of the unit.\n    \"\"\"\n\n    get_msg = await self.send_request(\n        MGMSG.QUAD_REQ_PARAMS,\n        [MGMSG.QUAD_GET_PARAMS],\n        param1=QUADMSG.QUAD_OPER_MODE_SUB_ID.value,\n    )\n    return st.unpack(\"&lt;HH\", get_msg.data)[1]\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.get_quad_position_demand_params","title":"<code>get_quad_position_demand_params()</code>  <code>async</code>","text":"<p>Get position demand parameters for the quad system.</p> <p>:return: A tuple containing x_pos_min, x_pos_max, y_pos_min, and y_pos_max.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def get_quad_position_demand_params(self) -&gt; tuple[int, int, int, int]:\n    \"\"\"Get position demand parameters for the quad system.\n\n    :return: A tuple containing x_pos_min, x_pos_max, y_pos_min, and y_pos_max.\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.QUAD_REQ_PARAMS,\n        [MGMSG.QUAD_GET_PARAMS],\n        param1=QUADMSG.QUAD_POSITION_DEMAND_PARAMS_SUB_ID.value,\n    )\n    return st.unpack(\"&lt;hhhhhhhhh\", get_msg.data)[1:]\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.get_quad_position_outputs","title":"<code>get_quad_position_outputs()</code>  <code>async</code>","text":"<p>Get the X and Y position outputs.</p> <p>:return: A tuple containing x_pos and y_pos.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def get_quad_position_outputs(self) -&gt; tuple[int, int]:\n    \"\"\"Get the X and Y position outputs.\n\n    :return: A tuple containing x_pos and y_pos.\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.QUAD_REQ_PARAMS,\n        [MGMSG.QUAD_GET_PARAMS],\n        param1=QUADMSG.QUAD_POSITION_OUTPUTS_SUB_ID.value,\n    )\n    return st.unpack(\"&lt;Hhh\", get_msg.data)[1:]\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.get_quad_readings","title":"<code>get_quad_readings()</code>  <code>async</code>","text":"<p>Get the status bits of the quad readings.</p> <p>:return: Status bits of the quad reading.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def get_quad_readings(self) -&gt; tuple[int, int, int, int, int]:\n    \"\"\"Get the status bits of the quad readings.\n\n    :return: Status bits of the quad reading.\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.QUAD_REQ_PARAMS,\n        [MGMSG.QUAD_GET_PARAMS],\n        param1=QUADMSG.QUAD_READINGS_SUB_ID.value,\n    )\n    return st.unpack(\"HHHHHH\", get_msg.data)[1:]\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.get_quad_status_bits","title":"<code>get_quad_status_bits()</code>  <code>async</code>","text":"<p>Get the status bits of the control unit.</p> <p>:return: Status bits of the control unit.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def get_quad_status_bits(self) -&gt; int:\n    \"\"\"Get the status bits of the control unit.\n\n    :return: Status bits of the control unit.\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.QUAD_REQ_PARAMS,\n        [MGMSG.QUAD_GET_PARAMS],\n        param1=QUADMSG.QUAD_STATUS_BITS_SUB_ID.value,\n    )\n    return st.unpack(\"&lt;HI\", get_msg.data)[1]\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.handle_message","title":"<code>handle_message(msg)</code>  <code>async</code>","text":"<p>Handle incoming messages from the TPA101 device.</p> <p>:param msg: Message object received from the device.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def handle_message(self, msg: Message) -&gt; None:\n    \"\"\"Handle incoming messages from the TPA101 device.\n\n    :param msg: Message object received from the device.\n    \"\"\"\n    msg_id: MGMSG = msg.id\n    data: bytes = msg.data\n\n    if msg_id == MGMSG.HW_DISCONNECT:\n        raise MsgError(\"Error: Please disconnect the TPA101\")\n\n    elif msg_id == MGMSG.HW_RESPONSE:\n        raise MsgError(\"Hardware error, please disconnect and reconnect the TPA101\")\n\n    elif msg_id == MGMSG.QUAD_GET_STATUSUPDATE:\n        x_diff, y_diff, sum_val, x_pos, y_pos, status_bits = st.unpack(\n            \"&lt;hhIhhI\", data[6:20]\n        )\n\n        # Update internal state variables with the extracted values\n        self.x_diff = x_diff\n        self.y_diff = y_diff\n        self.sum_val = sum_val\n        self.x_pos = x_pos\n        self.y_pos = y_pos\n        self.status_bits = status_bits\n\n        if self.status_report_counter == 25:\n            self.status_report_counter = 0\n            await self.send(Message(MGMSG.QUAD_ACK_STATUSUPDATE))\n        else:\n            self.status_report_counter += 1\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.set_eeprom_params","title":"<code>set_eeprom_params(msg_id)</code>  <code>async</code>","text":"<p>Save the parameter settings for the specified message.</p> <p>:param msg_id: The message ID of the message containing the parameters to be saved.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def set_eeprom_params(self, msg_id: int) -&gt; None:\n    \"\"\"Save the parameter settings for the specified message.\n\n    :param msg_id: The message ID of the message containing the parameters to be saved.\n    \"\"\"\n    payload = st.pack(\"&lt;H\", msg_id)\n    await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.set_loop_params","title":"<code>set_loop_params(p_gain, i_gain, d_gain)</code>  <code>async</code>","text":"<p>Set proportional, integral, and differential feedback loop constants.</p> <p>:param p_gain: Proportional gain value. :param i_gain: Integral gain value. :param d_gain: Differential gain value.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def set_loop_params(self, p_gain: int, i_gain: int, d_gain: int) -&gt; None:\n    \"\"\"Set proportional, integral, and differential feedback loop constants.\n\n    :param p_gain: Proportional gain value.\n    :param i_gain: Integral gain value.\n    :param d_gain: Differential gain value.\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HHHH\", QUADMSG.QUAD_LOOP_PARAMS_SUB_ID.value, p_gain, i_gain, d_gain\n    )\n    await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.set_quad_display_settings","title":"<code>set_quad_display_settings(disp_intensity, disp_mode, disp_dim_timeout)</code>  <code>async</code>","text":"<p>Set the display settings for the quad system.</p> <p>:param disp_intensity: Display intensity (0-255). :param disp_mode: Display mode (1 for Difference, 2 for Position). :param disp_dim_timeout: Dim timeout value as per documentation.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def set_quad_display_settings(\n    self, disp_intensity: int, disp_mode: int, disp_dim_timeout: int\n) -&gt; None:\n    \"\"\"Set the display settings for the quad system.\n\n    :param disp_intensity: Display intensity (0-255).\n    :param disp_mode: Display mode (1 for Difference, 2 for Position).\n    :param disp_dim_timeout: Dim timeout value as per documentation.\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HHHH\",\n        QUADMSG.QUAD_DISP_SETTINGS_SUB_ID.value,\n        disp_intensity,\n        disp_mode,\n        disp_dim_timeout,\n    )\n    await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.set_quad_loop_params_two","title":"<code>set_quad_loop_params_two(p_gain, i_gain, d_gain, d_cutoff_freq, notch_freq, filter_q, notch_on, deriv_filter_on)</code>  <code>async</code>","text":"<p>Set the extended loop parameters for the quad system.</p> <p>:param p_gain: Proportional gain value. :param i_gain: Integral gain value. :param d_gain: Differential gain value. :param d_cutoff_freq: Differential cutoff frequency. :param notch_freq: Notch filter frequency. :param filter_q: Filter quality factor. :param notch_on: Notch filter on/off flag. :param deriv_filter_on: Derivative filter on/off flag.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def set_quad_loop_params_two(\n    self,\n    p_gain: float,\n    i_gain: float,\n    d_gain: float,\n    d_cutoff_freq: float,\n    notch_freq: float,\n    filter_q: float,\n    notch_on: int,\n    deriv_filter_on: int,\n) -&gt; None:\n    \"\"\"Set the extended loop parameters for the quad system.\n\n    :param p_gain: Proportional gain value.\n    :param i_gain: Integral gain value.\n    :param d_gain: Differential gain value.\n    :param d_cutoff_freq: Differential cutoff frequency.\n    :param notch_freq: Notch filter frequency.\n    :param filter_q: Filter quality factor.\n    :param notch_on: Notch filter on/off flag.\n    :param deriv_filter_on: Derivative filter on/off flag.\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HFFFFFFHH\",\n        QUADMSG.QUAD_LOOP_PARAMS_TWO_SUB_ID.value,\n        p_gain,\n        i_gain,\n        d_gain,\n        d_cutoff_freq,\n        notch_freq,\n        filter_q,\n        notch_on,\n        deriv_filter_on,\n    )\n    await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.set_quad_oper_mode","title":"<code>set_quad_oper_mode(mode)</code>  <code>async</code>","text":"<p>Set the operating mode of the unit.</p> <p>:param mode: 1 for Monitor Mode, 2 for Open Loop, 3 for Closed Loop.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def set_quad_oper_mode(self, mode: int) -&gt; None:\n    \"\"\"Set the operating mode of the unit.\n\n    :param mode: 1 for Monitor Mode, 2 for Open Loop, 3 for Closed Loop.\n    \"\"\"\n\n    payload = st.pack(\"&lt;HH\", QUADMSG.QUAD_OPER_MODE_SUB_ID.value, mode)\n    await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.set_quad_position_demand_params","title":"<code>set_quad_position_demand_params(x_pos_min, x_pos_max, y_pos_min, y_pos_max, low_volt_output_route, open_loop_pos_demands, x_pos_demand_feedback_sense, y_pos_demand_feedback_sense)</code>  <code>async</code>","text":"<p>Set position demand parameters for the quad system.</p> <p>:param x_pos_min: Minimum X-axis position demand. :param x_pos_max: Maximum X-axis position demand. :param y_pos_min: Minimum Y-axis position demand. :param y_pos_max: Maximum Y-axis position demand. :param low_volt_output_route: LV output signal routing :param open_loop_pos_demands: Open loop position demands configuration :param x_pos_demand_feedback_sense: Signal sense and gain for X-axis output :param y_pos_demand_feedback_sense: Signal sense and gain for Y-axis output</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def set_quad_position_demand_params(\n    self,\n    x_pos_min: int,\n    x_pos_max: int,\n    y_pos_min: int,\n    y_pos_max: int,\n    low_volt_output_route: int,\n    open_loop_pos_demands: int,\n    x_pos_demand_feedback_sense: float,\n    y_pos_demand_feedback_sense: float,\n) -&gt; None:\n    \"\"\"Set position demand parameters for the quad system.\n\n    :param x_pos_min: Minimum X-axis position demand.\n    :param x_pos_max: Maximum X-axis position demand.\n    :param y_pos_min: Minimum Y-axis position demand.\n    :param y_pos_max: Maximum Y-axis position demand.\n    :param low_volt_output_route: LV output signal routing\n    :param open_loop_pos_demands: Open loop position demands configuration\n    :param x_pos_demand_feedback_sense: Signal sense and gain for X-axis output\n    :param y_pos_demand_feedback_sense: Signal sense and gain for Y-axis output\n    \"\"\"\n    payload = st.pack(\n        \"&lt;hhhhhhhhh\",\n        QUADMSG.QUAD_POSITION_DEMAND_PARAMS_SUB_ID.value,\n        x_pos_min,\n        x_pos_max,\n        y_pos_min,\n        y_pos_max,\n        low_volt_output_route,\n        open_loop_pos_demands,\n        x_pos_demand_feedback_sense,\n        y_pos_demand_feedback_sense,\n    )\n    await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpa101/#thorlabs_cube.driver.tcube.tpa.Tpa.set_quad_position_outputs","title":"<code>set_quad_position_outputs(x_pos, y_pos)</code>  <code>async</code>","text":"<p>Set the X and Y position outputs.</p> <p>:param x_pos: X-axis position output value (-32768 to 32767). :param y_pos: Y-axis position output value (-32768 to 32767).</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpa.py</code> <pre><code>async def set_quad_position_outputs(self, x_pos: int, y_pos: int) -&gt; None:\n    \"\"\"Set the X and Y position outputs.\n\n    :param x_pos: X-axis position output value (-32768 to 32767).\n    :param y_pos: Y-axis position output value (-32768 to 32767).\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HHH\", QUADMSG.QUAD_POSITION_OUTPUTS_SUB_ID.value, x_pos, y_pos\n    )\n    await self.send(Message(MGMSG.QUAD_SET_PARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/","title":"TPZ001","text":""},{"location":"sections/cube/tcube/tpz001/#controller-description","title":"Controller Description","text":"<p>The TPZ001 is a compact single-channel T-Cube controller from Thorlabs designed for precise control of piezoelectric actuators. It provides highly accurate position control for applications requiring nanometer-level precision. The TPZ001 supports closed-loop operation with feedback from piezo sensors and is compatible with Thorlabs\u2019 piezo actuators. It features USB connectivity for computer control via Thorlabs\u2019 Kinesis Software or QuantumION's Thorlabs Cube Repository.</p>"},{"location":"sections/cube/tcube/tpz001/#controller-use-cases","title":"Controller Use-Cases","text":"<ul> <li>TPZ001 is ideal for applications requiring ultra-fine positioning, such as:<ol> <li>Nanopositioning: High-precision adjustments of optical components.</li> <li>Interferometry: Fine control of optical path lengths for precision measurements.</li> <li>Microscopy: Managing piezo-driven sample stages for sub-micron positioning.</li> </ol> </li> </ul>"},{"location":"sections/cube/tcube/tpz001/#peripherals-examples","title":"Peripherals Examples","text":"<ul> <li>Piezoelectric Actuators</li> </ul> <ul> <li>Piezo-Driven Mirror Mounts</li> </ul> <ul> <li>Piezo Translation Stages</li> </ul>"},{"location":"sections/cube/tcube/tpz001/#api-reference","title":"API Reference","text":"<p>               Bases: <code>_Cube</code></p> <p>Either :py:meth:<code>set_tpz_io_settings()&lt;Tpz.set_tpz_io_settings&gt;</code> or :py:meth:<code>get_tpz_io_settings()&lt;Tpz.get_tpz_io_settings&gt;</code> must be completed to finish initialising the driver.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>class Tpz(_Cube):\n    \"\"\"Either :py:meth:`set_tpz_io_settings()&lt;Tpz.set_tpz_io_settings&gt;`\n    or :py:meth:`get_tpz_io_settings()&lt;Tpz.get_tpz_io_settings&gt;` must\n    be completed to finish initialising the driver.\n    \"\"\"\n\n    def __init__(self, serial_dev) -&gt; None:\n        super().__init__(serial_dev)\n        self.voltage_limit: Optional[int] = None\n\n    async def handle_message(self, msg) -&gt; None:\n        msg_id = msg.id\n        data = msg.data\n\n        if msg_id == MGMSG.HW_DISCONNECT:\n            raise MsgError(\"Error: Please disconnect the TPZ001\")\n        elif msg_id == MGMSG.HW_RESPONSE:\n            raise MsgError(\n                \"Hardware error, please disconnect \" \"and reconnect the TPZ001\"\n            )\n        elif msg_id == MGMSG.HW_RICHRESPONSE:\n            (code,) = st.unpack(\"&lt;H\", data[2:4])\n            raise MsgError(\n                \"Hardware error {}: {}\".format(\n                    code,\n                    data[4:].decode(encoding=\"ascii\"),\n                )\n            )\n\n    async def set_position_control_mode(self, control_mode: int) -&gt; None:\n        \"\"\"Set the control loop mode.\n\n        When in closed-loop mode, position is maintained by a feedback signal\n        from the piezo actuator. This is only possible when using actuators\n        equipped with position sensing.\n\n        :param control_mode: 0x01 for Open Loop (no feedback).\n            0x02 for Closed Loop (feedback employed).\n            0x03 for Open Loop Smooth.\n            0x04 for Closed Loop Smooth.\n        \"\"\"\n        await self.send(\n            Message(\n                MGMSG.PZ_SET_POSCONTROLMODE, param1=Tpz._CHANNEL, param2=control_mode\n            )\n        )\n\n    async def get_position_control_mode(self) -&gt; int:\n        \"\"\"Get the control loop mode.\n\n        :return: Returns the control mode.\n            0x01 for Open Loop (no feedback).\n            0x02 for Closed Loop (feedback employed).\n            0x03 for Open Loop Smooth.\n            0x04 for Closed Loop Smooth.\n        :rtype: int\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.PZ_REQ_POSCONTROLMODE, [MGMSG.PZ_GET_POSCONTROLMODE], Tpz._CHANNEL\n        )\n        return get_msg.param2\n\n    async def set_output_volts(self, voltage: float) -&gt; None:\n        \"\"\"Set output voltage applied to the piezo actuator.\n\n        This command is only applicable in Open Loop mode. If called when in\n        Closed Loop mode it is ignored.\n\n        :param voltage: The output voltage applied to the piezo when operating\n            in open loop mode. The voltage value must be in range\n            [0; voltage_limit]. Voltage_limit being set by the\n            :py:meth:`set_tpz_io_settings()&lt;Tpz.set_tpz_io_settings&gt;`\n            method between the three values 75 V, 100 V and 150 V.\n        \"\"\"\n        if self.voltage_limit is None:\n            raise ValueError(\"Voltage limit is not set\")\n\n        if voltage &lt; 0 or voltage &gt; self.voltage_limit:\n            raise ValueError(\n                \"Voltage must be in range [0;{}]\".format(self.voltage_limit)\n            )\n        volt = int(voltage * 32767 / self.voltage_limit)\n        payload = st.pack(\"&lt;HH\", Tpz._CHANNEL, volt)\n        await self.send(Message(MGMSG.PZ_SET_OUTPUTVOLTS, data=payload))\n\n    async def get_output_volts(self) -&gt; float:\n        \"\"\"Get the output voltage applied to the piezo actuator.\n\n        :return: The output voltage.\n        :rtype: float\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.PZ_REQ_OUTPUTVOLTS, [MGMSG.PZ_GET_OUTPUTVOLTS], Tpz._CHANNEL\n        )\n        return st.unpack(\"&lt;H\", get_msg.data[2:])[0] * self.voltage_limit / 32767\n\n    async def set_output_position(self, position_sw: int) -&gt; None:\n        \"\"\"Set output position of the piezo actuator.\n\n        This command is only applicable in Closed Loop mode. If called when in\n        Open Loop mode, it is ignored. The position of the actuator is relative\n        to the datum set for the arrangement using the ZeroPosition method.\n\n        :param position_sw: The output position of the piezo relative to the\n            zero position. The voltage is set in the range [0; 32767] or\n            [0; 65535] depending on the unit. This corresponds to 0 to 100% of\n            the maximum piezo extension.\n        \"\"\"\n        payload = st.pack(\"&lt;HH\", Tpz._CHANNEL, position_sw)\n        await self.send(Message(MGMSG.PZ_SET_OUTPUTPOS, data=payload))\n\n    async def get_output_position(self) -&gt; int:\n        \"\"\"Get output position of piezo actuator.\n\n        :return: The output position of the piezo relative to the zero\n            position.\n        :rtype: int\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.PZ_REQ_OUTPUTPOS, [MGMSG.PZ_GET_OUTPUTPOS], Tpz._CHANNEL\n        )\n        return st.unpack(\"&lt;H\", get_msg.data[2:])[0]\n\n    async def set_input_volts_source(self, volt_src: int) -&gt; None:\n        \"\"\"Set the input source(s) which controls the output from the HV\n        amplifier circuit (i.e. the drive to the piezo actuators).\n\n        :param volt_src: The following values are entered into the VoltSrc\n            parameter to select the various analog sources:\n\n            0x00 Software Only: Unit responds only to software inputs and the\n            HV amp output is that set using the :py:meth:`set_output_volts()`\n            &lt;Tpz.set_output_volts&gt;` method.\n\n            0x01 External Signal: Unit sums the differential signal on the rear\n            panel EXT IN(+) and EXT IN(-) connectors with the voltage set\n            using the set_outputvolts method.\n\n            0x02 Potentiometer: The HV amp output is controlled by a\n            potentiometer input (either on the control panel, or connected\n            to the rear panel User I/O D-type connector) summed with the\n            voltage set using the set_outputvolts method.\n\n            The values can be bitwise or'ed to sum the software source with\n            either or both of the other source options.\n        \"\"\"\n        payload = st.pack(\"&lt;HH\", Tpz._CHANNEL, volt_src)\n        await self.send(Message(MGMSG.PZ_SET_INPUTVOLTSSRC, data=payload))\n\n    async def get_input_volts_source(self) -&gt; int:\n        \"\"\"Get the input source(s) which controls the output from the HV\n        amplifier circuit.\n\n        :return: Value which selects the various analog sources, cf.\n            :py:meth:`set_input_volts_source()&lt;Tpz.set_input_volts_source&gt;`\n            method docstring for meaning of bits.\n        :rtype: int\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.PZ_REQ_INPUTVOLTSSRC, [MGMSG.PZ_GET_INPUTVOLTSSRC], Tpz._CHANNEL\n        )\n        return st.unpack(\"&lt;H\", get_msg.data[2:])[0]\n\n    async def set_pi_constants(self, prop_const: int, int_const: int) -&gt; None:\n        \"\"\"Set the proportional and integration feedback loop constants.\n\n        These parameters determine the response characteristics when operating\n        in closed loop mode.\n        The processors within the controller compare the required (demanded)\n        position with the actual position to create an error, which is then\n        passed through a digital PI-type filter. The filtered value is used to\n        develop an output voltage to drive the pizeo.\n\n        :param prop_const: Value of the proportional term in range [0; 255].\n        :param int_const: Value of the integral term in range [0; 255].\n        \"\"\"\n        payload = st.pack(\"&lt;HHH\", Tpz._CHANNEL, prop_const, int_const)\n        await self.send(Message(MGMSG.PZ_SET_PICONSTS, data=payload))\n\n    async def get_pi_constants(self) -&gt; tuple[int, int]:\n        \"\"\"Get the proportional and integration feedback loop constants.\n\n        :return: Returns a tuple whose first element is the proportional\n            term and the second element is the integral term.\n        :rtype: a 2 int elements tuple : (int, int)\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.PZ_REQ_PICONSTS, [MGMSG.PZ_GET_PICONSTS], Tpz._CHANNEL\n        )\n        return st.unpack(\"&lt;HH\", get_msg.data[2:])\n\n    async def set_output_lut(self, lut_index: int, output: float) -&gt; None:\n        \"\"\"Set the ouput LUT values for WGM (Waveform Generator Mode).\n\n        It is possible to use the controller in an arbitrary Waveform\n        Generator Mode (WGM). Rather than the unit outputting an adjustable\n        but static voltage or position, the WGM allows the user to define a\n        voltage or position sequence to be output, either periodically or a\n        fixed number of times, with a selectable interval between adjacent\n        samples.\n\n        This waveform generation function is particularly useful for\n        operations such as scanning over a particular area, or in any other\n        application that requires a predefined movement sequence. The waveform\n        is stored as values in an array, with a maximum of 513 samples.\n\n        The samples can have the meaning of voltage or position; if\n        open loop operation is specified when the samples are output, then\n        their meaning is voltage and vice versa, if the channel is set to\n        closed loop operation, the samples are interpreted as position values.\n\n        If the waveform to be output requires less than 513 samples, it is\n        sufficient to download the desired number of samples. This function is\n        used to load the LUT array with the required output waveform. The\n        applicable channel is specified by the Chan Ident parameter If only a\n        sub set of the array is being used (as specified by the cyclelength\n        parameter of the :py:meth:`set_output_lut_parameters()`\n        &lt;Tpz.set_output_lut_parameters&gt;`\n        function), then only the first cyclelength values need to be set. In\n        this manner, any arbitrary voltage waveform can be programmed into the\n        LUT. Note. The LUT values are output by the system at a maximum\n        bandwidth of 7 KHz, e.g. 500 LUT values will take approximately 71 ms\n        to be clocked out.\n\n        :param lut_index: The position in the array of the value to be set (0\n            to 512 for TPZ).\n        :param output: The voltage value to be set. Values are in the range\n            [0; voltage_limit]. Voltage_limit being set with the\n            :py:meth:`set_tpz_io_settings&lt;Tpz.set_tpz_io_settings&gt;`\n            method.\n        \"\"\"\n        if self.voltage_limit is None:\n            raise ValueError(\"Voltage limit is not set\")\n\n        volt = round(output * 32767 / self.voltage_limit)\n        payload = st.pack(\"&lt;HHH\", Tpz._CHANNEL, lut_index, volt)\n        await self.send(Message(MGMSG.PZ_SET_OUTPUTLUT, data=payload))\n\n    async def get_output_lut(self) -&gt; tuple[int, float]:\n        \"\"\"Get the ouput LUT values for WGM (Waveform Generator Mode).\n\n        :return: a tuple whose first element is the lut index and the second is\n            the voltage output value.\n        :rtype: a 2 elements tuple (int, float)\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.PZ_REQ_OUTPUTLUT, [MGMSG.PZ_GET_OUTPUTLUT], Tpz._CHANNEL\n        )\n        index, output = st.unpack(\"&lt;Hh\", get_msg.data[2:])\n        return index, output * self.voltage_limit / 32767\n\n    async def set_output_lut_parameters(\n        self,\n        mode: int,\n        cycle_length: int,\n        num_cycles: int,\n        delay_time: int,\n        precycle_rest: int,\n        postcycle_rest: int,\n    ) -&gt; None:\n        \"\"\"Set Waveform Generator Mode parameters.\n\n        It is possible to use the controller in an arbitrary Waveform\n        Generator Mode (WGM). Rather than the unit outputting an adjustable\n        but static voltage or position, the WGM allows the user to define a\n        voltage or position sequence to be output, either periodically or a\n        fixed number of times, with a selectable interval between adjacent\n        samples.\n        This waveform generation function is particularly useful for operations\n        such as scanning over a particular area, or in any other application\n        that requires a predefined movement sequence. This function is used to\n        set parameters which control the output of the LUT array.\n\n        :param mode: Specifies the ouput mode of the LUT waveform as follows:\n\n            0x01 - Output Continuous - The waveform is output continuously\n            (i.e. until a StopOPLut command is received.)\n\n            0x02 - Output Fixed - A fixed number of waveform cycles are output\n            (as specified in the num_cycles parameter).\n        :param cycle_length: Specifies how many samples will be output in each\n            cycle of the waveform. It can be set in the range [0; 512]\n            (for TPZ). It must be less than or equal to the total number of\n            samples that were loaded.\n        :param num_cycles: Specifies the number of cycles (1 to 2147483648) to\n            be output when the Mode parameter is set to fixed. If Mode is set\n            to Continuous, the num_cycles parameter is ignored. In both cases,\n            the waveform is not output until a StartOPLUT command is received.\n        :param delay_time: Specifies the delay (in sample intervals) that the\n            system waits after setting each LUT output value. By default, the\n            time the system takes to output LUT values (sampling interval) is\n            set at the maximum bandwidth possible, i.e. 4 kHz (0.25 ms) for TPZ\n            units. The delay_time parameter specifies the time interval between\n            neighbouring samples, i.e. for how long the sample will remain at\n            its present value. To increase the time between samples, set the\n            delay_time parameter to the required additional delay (1 to\n            2147483648 sample intervals). In this way, the user can stretch or\n            shrink the waveform without affecting its overall shape.\n        :param precycle_rest: In some applications, during waveform generation\n            the first and the last samples may need to be handled differently\n            from the rest of the waveform. For example, in a positioning system\n            it may be necessary to start the movement by staying at a certain\n            position for a specified length of time, then perform a movement,\n            then remain at the last position for another specified length of\n            time. This is the purpose of precycle_rest and postcycle_rest\n            parameters, i.e. they specify the length of time that the first and\n            last samples are output for, independently of the delay_time\n            parameter. The precycle_rest parameter allows a delay time to be\n            set before the system starts to clock out the LUT values. The delay\n            can be set between 0 and 2147483648 sample intervals. The system\n            then outputs the first value in the LUT until the PreCycleRest time\n            has expired.\n        :param postcycle_rest: In a similar way to precycle_rest, the\n            postcycle_rest parameter specifies the delay imposed by the system\n            after a LUT table has been output. The delay can be set between 0\n            and 2147483648 sample intervals. The system then outputs the last\n            value in the cycle until the postcycle_rest time has expired.\n        \"\"\"\n        # triggering is not supported by the TPZ device\n        payload = st.pack(\n            \"&lt;HHHLLLLHLH\",\n            Tpz._CHANNEL,\n            mode,\n            cycle_length,\n            num_cycles,\n            delay_time,\n            precycle_rest,\n            postcycle_rest,\n            0,\n            0,\n            0,\n        )\n        await self.send(Message(MGMSG.PZ_SET_OUTPUTLUTPARAMS, data=payload))\n\n    async def get_output_lut_parameters(self) -&gt; tuple[int, int, int, int, int, int]:\n        \"\"\"Get Waveform Generator Mode parameters.\n\n        :return: a 6 int elements tuple whose members are (mode, cycle_length,\n            num_cycles, delay_time, precycle_rest, postcycle_rest).\n        :rtype: 6 int elements tuple\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.PZ_REQ_OUTPUTLUTPARAMS,\n            [MGMSG.PZ_GET_OUTPUTLUTPARAMS],\n            Tpz._CHANNEL,\n        )\n        return st.unpack(\"&lt;HHLLLL\", get_msg.data[2:22])\n\n    async def start_lut_output(self) -&gt; None:\n        \"\"\"Start the voltage waveform (LUT) outputs.\"\"\"\n        await self.send(Message(MGMSG.PZ_START_LUTOUTPUT, param1=Tpz._CHANNEL))\n\n    async def stop_lut_output(self) -&gt; None:\n        \"\"\"Stop the voltage waveform (LUT) outputs.\"\"\"\n        await self.send(Message(MGMSG.PZ_STOP_LUTOUTPUT, param1=Tpz._CHANNEL))\n\n    async def set_eeprom_parameters(self, msg_id: int) -&gt; None:\n        \"\"\"Save the parameter settings for the specified message.\n\n        :param msg_id: The message ID of the message containing the parameters\n            to be saved.\n        \"\"\"\n        payload = st.pack(\"&lt;HH\", Tpz._CHANNEL, msg_id)\n        await self.send(Message(MGMSG.PZ_SET_EEPROMPARAMS, data=payload))\n\n    async def set_tpz_display_settings(self, intensity: int) -&gt; None:\n        \"\"\"Set the intensity of the LED display on the front of the TPZ unit.\n\n        :param intensity: The intensity is set as a value from 0 (Off) to 255\n            (brightest).\n        \"\"\"\n        payload = st.pack(\"&lt;H\", intensity)\n        await self.send(Message(MGMSG.PZ_SET_TPZ_DISPSETTINGS, data=payload))\n\n    async def get_tpz_display_settings(self) -&gt; int:\n        \"\"\"Get the intensity of the LED display on the front of the TPZ unit.\n\n        :return: The intensity as a value from 0 (Off) to 255 (brightest).\n        :rtype: int\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.PZ_REQ_TPZ_DISPSETTINGS, [MGMSG.PZ_GET_TPZ_DISPSETTINGS], Tpz._CHANNEL\n        )\n        return st.unpack(\"&lt;H\", get_msg.data)[0]\n\n    async def set_tpz_io_settings(\n        self, voltage_limit: int, hub_analog_input: int\n    ) -&gt; None:\n        \"\"\"Set various I/O settings.\n\n        :param voltage_limit: The piezo actuator connected to the T-Cube has a\n            specific maximum operating voltage. This parameter sets the maximum\n            output to the value among the following ones:\n\n            75 V limit.\n\n            100 V limit.\n\n            150 V limit.\n        :param hub_analog_input: When the T-Cube piezo driver unit is used in\n            conjunction with the T-Cube Strain Gauge Reader (TSG001) on the\n            T-Cube Controller Hub (TCH001), a feedback signal can be passed\n            from the Strain Gauge Reader to the Piezo unit.\n            High precision closed loop operation is then possible using the\n            complete range of feedback-equipped piezo actuators.\n            This parameter is routed to the Piezo unit as follows:\n\n            0x01: the feedback signals run through all T-Cube bays.\n\n            0x02: the feedback signals run between adjacent pairs of T-Cube\n            bays (i.e. 1&amp;2, 3&amp;4, 5&amp;6). This setting is useful when several\n            pairs of Strain Gauge/Piezo Driver cubes are being used on the same\n            hub.\n\n            0x03: the feedback signals run through the read panel SMA\n            connectors.\n        \"\"\"\n        self.voltage_limit = voltage_limit\n\n        if self.voltage_limit == 75:\n            voltage_limit = 1\n        elif self.voltage_limit == 100:\n            voltage_limit = 2\n        elif self.voltage_limit == 150:\n            voltage_limit = 3\n        else:\n            raise ValueError(\"voltage_limit must be 75 V, 100 V or 150 V\")\n\n        payload = st.pack(\n            \"&lt;HHHHH\",\n            Tpz._CHANNEL,\n            voltage_limit,\n            hub_analog_input,\n            Tpz._RESERVED,\n            Tpz._RESERVED,\n        )\n        await self.send(Message(MGMSG.PZ_SET_TPZ_IOSETTINGS, data=payload))\n\n    async def get_tpz_io_settings(self) -&gt; tuple[int, int]:\n        \"\"\"Get various I/O settings.\n\n        :return: Returns a tuple whose elements are the voltage limit and the\n            Hub analog input. Refer to :py:meth:`set_tpz_io_settings()`\n            &lt;Tpz.set_tpz_io_settings&gt;` for\n            the meaning of those parameters.\n        :rtype: a 2 elements tuple (int, int)\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.PZ_REQ_TPZ_IOSETTINGS, [MGMSG.PZ_GET_TPZ_IOSETTINGS], Tpz._CHANNEL\n        )\n        voltage_limit, hub_analog_input = st.unpack(\"&lt;HH\", get_msg.data[2:6])\n        if voltage_limit == 1:\n            voltage_limit = 75\n        elif voltage_limit == 2:\n            voltage_limit = 100\n        elif voltage_limit == 3:\n            voltage_limit = 150\n        else:\n            raise ValueError(\"Voltage limit should be in range [1; 3]\")\n        self.voltage_limit = voltage_limit\n        return voltage_limit, hub_analog_input\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.get_input_volts_source","title":"<code>get_input_volts_source()</code>  <code>async</code>","text":"<p>Get the input source(s) which controls the output from the HV amplifier circuit.</p> <p>:return: Value which selects the various analog sources, cf.     :py:meth:<code>set_input_volts_source()&lt;Tpz.set_input_volts_source&gt;</code>     method docstring for meaning of bits. :rtype: int</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def get_input_volts_source(self) -&gt; int:\n    \"\"\"Get the input source(s) which controls the output from the HV\n    amplifier circuit.\n\n    :return: Value which selects the various analog sources, cf.\n        :py:meth:`set_input_volts_source()&lt;Tpz.set_input_volts_source&gt;`\n        method docstring for meaning of bits.\n    :rtype: int\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.PZ_REQ_INPUTVOLTSSRC, [MGMSG.PZ_GET_INPUTVOLTSSRC], Tpz._CHANNEL\n    )\n    return st.unpack(\"&lt;H\", get_msg.data[2:])[0]\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.get_output_lut","title":"<code>get_output_lut()</code>  <code>async</code>","text":"<p>Get the ouput LUT values for WGM (Waveform Generator Mode).</p> <p>:return: a tuple whose first element is the lut index and the second is     the voltage output value. :rtype: a 2 elements tuple (int, float)</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def get_output_lut(self) -&gt; tuple[int, float]:\n    \"\"\"Get the ouput LUT values for WGM (Waveform Generator Mode).\n\n    :return: a tuple whose first element is the lut index and the second is\n        the voltage output value.\n    :rtype: a 2 elements tuple (int, float)\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.PZ_REQ_OUTPUTLUT, [MGMSG.PZ_GET_OUTPUTLUT], Tpz._CHANNEL\n    )\n    index, output = st.unpack(\"&lt;Hh\", get_msg.data[2:])\n    return index, output * self.voltage_limit / 32767\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.get_output_lut_parameters","title":"<code>get_output_lut_parameters()</code>  <code>async</code>","text":"<p>Get Waveform Generator Mode parameters.</p> <p>:return: a 6 int elements tuple whose members are (mode, cycle_length,     num_cycles, delay_time, precycle_rest, postcycle_rest). :rtype: 6 int elements tuple</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def get_output_lut_parameters(self) -&gt; tuple[int, int, int, int, int, int]:\n    \"\"\"Get Waveform Generator Mode parameters.\n\n    :return: a 6 int elements tuple whose members are (mode, cycle_length,\n        num_cycles, delay_time, precycle_rest, postcycle_rest).\n    :rtype: 6 int elements tuple\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.PZ_REQ_OUTPUTLUTPARAMS,\n        [MGMSG.PZ_GET_OUTPUTLUTPARAMS],\n        Tpz._CHANNEL,\n    )\n    return st.unpack(\"&lt;HHLLLL\", get_msg.data[2:22])\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.get_output_position","title":"<code>get_output_position()</code>  <code>async</code>","text":"<p>Get output position of piezo actuator.</p> <p>:return: The output position of the piezo relative to the zero     position. :rtype: int</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def get_output_position(self) -&gt; int:\n    \"\"\"Get output position of piezo actuator.\n\n    :return: The output position of the piezo relative to the zero\n        position.\n    :rtype: int\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.PZ_REQ_OUTPUTPOS, [MGMSG.PZ_GET_OUTPUTPOS], Tpz._CHANNEL\n    )\n    return st.unpack(\"&lt;H\", get_msg.data[2:])[0]\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.get_output_volts","title":"<code>get_output_volts()</code>  <code>async</code>","text":"<p>Get the output voltage applied to the piezo actuator.</p> <p>:return: The output voltage. :rtype: float</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def get_output_volts(self) -&gt; float:\n    \"\"\"Get the output voltage applied to the piezo actuator.\n\n    :return: The output voltage.\n    :rtype: float\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.PZ_REQ_OUTPUTVOLTS, [MGMSG.PZ_GET_OUTPUTVOLTS], Tpz._CHANNEL\n    )\n    return st.unpack(\"&lt;H\", get_msg.data[2:])[0] * self.voltage_limit / 32767\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.get_pi_constants","title":"<code>get_pi_constants()</code>  <code>async</code>","text":"<p>Get the proportional and integration feedback loop constants.</p> <p>:return: Returns a tuple whose first element is the proportional     term and the second element is the integral term. :rtype: a 2 int elements tuple : (int, int)</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def get_pi_constants(self) -&gt; tuple[int, int]:\n    \"\"\"Get the proportional and integration feedback loop constants.\n\n    :return: Returns a tuple whose first element is the proportional\n        term and the second element is the integral term.\n    :rtype: a 2 int elements tuple : (int, int)\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.PZ_REQ_PICONSTS, [MGMSG.PZ_GET_PICONSTS], Tpz._CHANNEL\n    )\n    return st.unpack(\"&lt;HH\", get_msg.data[2:])\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.get_position_control_mode","title":"<code>get_position_control_mode()</code>  <code>async</code>","text":"<p>Get the control loop mode.</p> <p>:return: Returns the control mode.     0x01 for Open Loop (no feedback).     0x02 for Closed Loop (feedback employed).     0x03 for Open Loop Smooth.     0x04 for Closed Loop Smooth. :rtype: int</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def get_position_control_mode(self) -&gt; int:\n    \"\"\"Get the control loop mode.\n\n    :return: Returns the control mode.\n        0x01 for Open Loop (no feedback).\n        0x02 for Closed Loop (feedback employed).\n        0x03 for Open Loop Smooth.\n        0x04 for Closed Loop Smooth.\n    :rtype: int\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.PZ_REQ_POSCONTROLMODE, [MGMSG.PZ_GET_POSCONTROLMODE], Tpz._CHANNEL\n    )\n    return get_msg.param2\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.get_tpz_display_settings","title":"<code>get_tpz_display_settings()</code>  <code>async</code>","text":"<p>Get the intensity of the LED display on the front of the TPZ unit.</p> <p>:return: The intensity as a value from 0 (Off) to 255 (brightest). :rtype: int</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def get_tpz_display_settings(self) -&gt; int:\n    \"\"\"Get the intensity of the LED display on the front of the TPZ unit.\n\n    :return: The intensity as a value from 0 (Off) to 255 (brightest).\n    :rtype: int\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.PZ_REQ_TPZ_DISPSETTINGS, [MGMSG.PZ_GET_TPZ_DISPSETTINGS], Tpz._CHANNEL\n    )\n    return st.unpack(\"&lt;H\", get_msg.data)[0]\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.get_tpz_io_settings","title":"<code>get_tpz_io_settings()</code>  <code>async</code>","text":"<p>Get various I/O settings.</p> <p>:return: Returns a tuple whose elements are the voltage limit and the     Hub analog input. Refer to :py:meth:<code>set_tpz_io_settings()</code> ` for     the meaning of those parameters. :rtype: a 2 elements tuple (int, int) Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def get_tpz_io_settings(self) -&gt; tuple[int, int]:\n    \"\"\"Get various I/O settings.\n\n    :return: Returns a tuple whose elements are the voltage limit and the\n        Hub analog input. Refer to :py:meth:`set_tpz_io_settings()`\n        &lt;Tpz.set_tpz_io_settings&gt;` for\n        the meaning of those parameters.\n    :rtype: a 2 elements tuple (int, int)\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.PZ_REQ_TPZ_IOSETTINGS, [MGMSG.PZ_GET_TPZ_IOSETTINGS], Tpz._CHANNEL\n    )\n    voltage_limit, hub_analog_input = st.unpack(\"&lt;HH\", get_msg.data[2:6])\n    if voltage_limit == 1:\n        voltage_limit = 75\n    elif voltage_limit == 2:\n        voltage_limit = 100\n    elif voltage_limit == 3:\n        voltage_limit = 150\n    else:\n        raise ValueError(\"Voltage limit should be in range [1; 3]\")\n    self.voltage_limit = voltage_limit\n    return voltage_limit, hub_analog_input\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.set_eeprom_parameters","title":"<code>set_eeprom_parameters(msg_id)</code>  <code>async</code>","text":"<p>Save the parameter settings for the specified message.</p> <p>:param msg_id: The message ID of the message containing the parameters     to be saved.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def set_eeprom_parameters(self, msg_id: int) -&gt; None:\n    \"\"\"Save the parameter settings for the specified message.\n\n    :param msg_id: The message ID of the message containing the parameters\n        to be saved.\n    \"\"\"\n    payload = st.pack(\"&lt;HH\", Tpz._CHANNEL, msg_id)\n    await self.send(Message(MGMSG.PZ_SET_EEPROMPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.set_input_volts_source","title":"<code>set_input_volts_source(volt_src)</code>  <code>async</code>","text":"<p>Set the input source(s) which controls the output from the HV amplifier circuit (i.e. the drive to the piezo actuators).</p> <p>:param volt_src: The following values are entered into the VoltSrc     parameter to select the various analog sources:</p> <pre><code>0x00 Software Only: Unit responds only to software inputs and the\nHV amp output is that set using the :py:meth:`set_output_volts()`\n&lt;Tpz.set_output_volts&gt;` method.\n\n0x01 External Signal: Unit sums the differential signal on the rear\npanel EXT IN(+) and EXT IN(-) connectors with the voltage set\nusing the set_outputvolts method.\n\n0x02 Potentiometer: The HV amp output is controlled by a\npotentiometer input (either on the control panel, or connected\nto the rear panel User I/O D-type connector) summed with the\nvoltage set using the set_outputvolts method.\n\nThe values can be bitwise or'ed to sum the software source with\neither or both of the other source options.\n</code></pre> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def set_input_volts_source(self, volt_src: int) -&gt; None:\n    \"\"\"Set the input source(s) which controls the output from the HV\n    amplifier circuit (i.e. the drive to the piezo actuators).\n\n    :param volt_src: The following values are entered into the VoltSrc\n        parameter to select the various analog sources:\n\n        0x00 Software Only: Unit responds only to software inputs and the\n        HV amp output is that set using the :py:meth:`set_output_volts()`\n        &lt;Tpz.set_output_volts&gt;` method.\n\n        0x01 External Signal: Unit sums the differential signal on the rear\n        panel EXT IN(+) and EXT IN(-) connectors with the voltage set\n        using the set_outputvolts method.\n\n        0x02 Potentiometer: The HV amp output is controlled by a\n        potentiometer input (either on the control panel, or connected\n        to the rear panel User I/O D-type connector) summed with the\n        voltage set using the set_outputvolts method.\n\n        The values can be bitwise or'ed to sum the software source with\n        either or both of the other source options.\n    \"\"\"\n    payload = st.pack(\"&lt;HH\", Tpz._CHANNEL, volt_src)\n    await self.send(Message(MGMSG.PZ_SET_INPUTVOLTSSRC, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.set_output_lut","title":"<code>set_output_lut(lut_index, output)</code>  <code>async</code>","text":"<p>Set the ouput LUT values for WGM (Waveform Generator Mode).</p> <p>It is possible to use the controller in an arbitrary Waveform Generator Mode (WGM). Rather than the unit outputting an adjustable but static voltage or position, the WGM allows the user to define a voltage or position sequence to be output, either periodically or a fixed number of times, with a selectable interval between adjacent samples.</p> <p>This waveform generation function is particularly useful for operations such as scanning over a particular area, or in any other application that requires a predefined movement sequence. The waveform is stored as values in an array, with a maximum of 513 samples.</p> <p>The samples can have the meaning of voltage or position; if open loop operation is specified when the samples are output, then their meaning is voltage and vice versa, if the channel is set to closed loop operation, the samples are interpreted as position values.</p> <p>If the waveform to be output requires less than 513 samples, it is sufficient to download the desired number of samples. This function is used to load the LUT array with the required output waveform. The applicable channel is specified by the Chan Ident parameter If only a sub set of the array is being used (as specified by the cyclelength parameter of the :py:meth:<code>set_output_lut_parameters()</code> ` function), then only the first cyclelength values need to be set. In this manner, any arbitrary voltage waveform can be programmed into the LUT. Note. The LUT values are output by the system at a maximum bandwidth of 7 KHz, e.g. 500 LUT values will take approximately 71 ms to be clocked out. <p>:param lut_index: The position in the array of the value to be set (0     to 512 for TPZ). :param output: The voltage value to be set. Values are in the range     [0; voltage_limit]. Voltage_limit being set with the     :py:meth:<code>set_tpz_io_settings&lt;Tpz.set_tpz_io_settings&gt;</code>     method.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def set_output_lut(self, lut_index: int, output: float) -&gt; None:\n    \"\"\"Set the ouput LUT values for WGM (Waveform Generator Mode).\n\n    It is possible to use the controller in an arbitrary Waveform\n    Generator Mode (WGM). Rather than the unit outputting an adjustable\n    but static voltage or position, the WGM allows the user to define a\n    voltage or position sequence to be output, either periodically or a\n    fixed number of times, with a selectable interval between adjacent\n    samples.\n\n    This waveform generation function is particularly useful for\n    operations such as scanning over a particular area, or in any other\n    application that requires a predefined movement sequence. The waveform\n    is stored as values in an array, with a maximum of 513 samples.\n\n    The samples can have the meaning of voltage or position; if\n    open loop operation is specified when the samples are output, then\n    their meaning is voltage and vice versa, if the channel is set to\n    closed loop operation, the samples are interpreted as position values.\n\n    If the waveform to be output requires less than 513 samples, it is\n    sufficient to download the desired number of samples. This function is\n    used to load the LUT array with the required output waveform. The\n    applicable channel is specified by the Chan Ident parameter If only a\n    sub set of the array is being used (as specified by the cyclelength\n    parameter of the :py:meth:`set_output_lut_parameters()`\n    &lt;Tpz.set_output_lut_parameters&gt;`\n    function), then only the first cyclelength values need to be set. In\n    this manner, any arbitrary voltage waveform can be programmed into the\n    LUT. Note. The LUT values are output by the system at a maximum\n    bandwidth of 7 KHz, e.g. 500 LUT values will take approximately 71 ms\n    to be clocked out.\n\n    :param lut_index: The position in the array of the value to be set (0\n        to 512 for TPZ).\n    :param output: The voltage value to be set. Values are in the range\n        [0; voltage_limit]. Voltage_limit being set with the\n        :py:meth:`set_tpz_io_settings&lt;Tpz.set_tpz_io_settings&gt;`\n        method.\n    \"\"\"\n    if self.voltage_limit is None:\n        raise ValueError(\"Voltage limit is not set\")\n\n    volt = round(output * 32767 / self.voltage_limit)\n    payload = st.pack(\"&lt;HHH\", Tpz._CHANNEL, lut_index, volt)\n    await self.send(Message(MGMSG.PZ_SET_OUTPUTLUT, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.set_output_lut_parameters","title":"<code>set_output_lut_parameters(mode, cycle_length, num_cycles, delay_time, precycle_rest, postcycle_rest)</code>  <code>async</code>","text":"<p>Set Waveform Generator Mode parameters.</p> <p>It is possible to use the controller in an arbitrary Waveform Generator Mode (WGM). Rather than the unit outputting an adjustable but static voltage or position, the WGM allows the user to define a voltage or position sequence to be output, either periodically or a fixed number of times, with a selectable interval between adjacent samples. This waveform generation function is particularly useful for operations such as scanning over a particular area, or in any other application that requires a predefined movement sequence. This function is used to set parameters which control the output of the LUT array.</p> <p>:param mode: Specifies the ouput mode of the LUT waveform as follows:</p> <pre><code>0x01 - Output Continuous - The waveform is output continuously\n(i.e. until a StopOPLut command is received.)\n\n0x02 - Output Fixed - A fixed number of waveform cycles are output\n(as specified in the num_cycles parameter).\n</code></pre> <p>:param cycle_length: Specifies how many samples will be output in each     cycle of the waveform. It can be set in the range [0; 512]     (for TPZ). It must be less than or equal to the total number of     samples that were loaded. :param num_cycles: Specifies the number of cycles (1 to 2147483648) to     be output when the Mode parameter is set to fixed. If Mode is set     to Continuous, the num_cycles parameter is ignored. In both cases,     the waveform is not output until a StartOPLUT command is received. :param delay_time: Specifies the delay (in sample intervals) that the     system waits after setting each LUT output value. By default, the     time the system takes to output LUT values (sampling interval) is     set at the maximum bandwidth possible, i.e. 4 kHz (0.25 ms) for TPZ     units. The delay_time parameter specifies the time interval between     neighbouring samples, i.e. for how long the sample will remain at     its present value. To increase the time between samples, set the     delay_time parameter to the required additional delay (1 to     2147483648 sample intervals). In this way, the user can stretch or     shrink the waveform without affecting its overall shape. :param precycle_rest: In some applications, during waveform generation     the first and the last samples may need to be handled differently     from the rest of the waveform. For example, in a positioning system     it may be necessary to start the movement by staying at a certain     position for a specified length of time, then perform a movement,     then remain at the last position for another specified length of     time. This is the purpose of precycle_rest and postcycle_rest     parameters, i.e. they specify the length of time that the first and     last samples are output for, independently of the delay_time     parameter. The precycle_rest parameter allows a delay time to be     set before the system starts to clock out the LUT values. The delay     can be set between 0 and 2147483648 sample intervals. The system     then outputs the first value in the LUT until the PreCycleRest time     has expired. :param postcycle_rest: In a similar way to precycle_rest, the     postcycle_rest parameter specifies the delay imposed by the system     after a LUT table has been output. The delay can be set between 0     and 2147483648 sample intervals. The system then outputs the last     value in the cycle until the postcycle_rest time has expired.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def set_output_lut_parameters(\n    self,\n    mode: int,\n    cycle_length: int,\n    num_cycles: int,\n    delay_time: int,\n    precycle_rest: int,\n    postcycle_rest: int,\n) -&gt; None:\n    \"\"\"Set Waveform Generator Mode parameters.\n\n    It is possible to use the controller in an arbitrary Waveform\n    Generator Mode (WGM). Rather than the unit outputting an adjustable\n    but static voltage or position, the WGM allows the user to define a\n    voltage or position sequence to be output, either periodically or a\n    fixed number of times, with a selectable interval between adjacent\n    samples.\n    This waveform generation function is particularly useful for operations\n    such as scanning over a particular area, or in any other application\n    that requires a predefined movement sequence. This function is used to\n    set parameters which control the output of the LUT array.\n\n    :param mode: Specifies the ouput mode of the LUT waveform as follows:\n\n        0x01 - Output Continuous - The waveform is output continuously\n        (i.e. until a StopOPLut command is received.)\n\n        0x02 - Output Fixed - A fixed number of waveform cycles are output\n        (as specified in the num_cycles parameter).\n    :param cycle_length: Specifies how many samples will be output in each\n        cycle of the waveform. It can be set in the range [0; 512]\n        (for TPZ). It must be less than or equal to the total number of\n        samples that were loaded.\n    :param num_cycles: Specifies the number of cycles (1 to 2147483648) to\n        be output when the Mode parameter is set to fixed. If Mode is set\n        to Continuous, the num_cycles parameter is ignored. In both cases,\n        the waveform is not output until a StartOPLUT command is received.\n    :param delay_time: Specifies the delay (in sample intervals) that the\n        system waits after setting each LUT output value. By default, the\n        time the system takes to output LUT values (sampling interval) is\n        set at the maximum bandwidth possible, i.e. 4 kHz (0.25 ms) for TPZ\n        units. The delay_time parameter specifies the time interval between\n        neighbouring samples, i.e. for how long the sample will remain at\n        its present value. To increase the time between samples, set the\n        delay_time parameter to the required additional delay (1 to\n        2147483648 sample intervals). In this way, the user can stretch or\n        shrink the waveform without affecting its overall shape.\n    :param precycle_rest: In some applications, during waveform generation\n        the first and the last samples may need to be handled differently\n        from the rest of the waveform. For example, in a positioning system\n        it may be necessary to start the movement by staying at a certain\n        position for a specified length of time, then perform a movement,\n        then remain at the last position for another specified length of\n        time. This is the purpose of precycle_rest and postcycle_rest\n        parameters, i.e. they specify the length of time that the first and\n        last samples are output for, independently of the delay_time\n        parameter. The precycle_rest parameter allows a delay time to be\n        set before the system starts to clock out the LUT values. The delay\n        can be set between 0 and 2147483648 sample intervals. The system\n        then outputs the first value in the LUT until the PreCycleRest time\n        has expired.\n    :param postcycle_rest: In a similar way to precycle_rest, the\n        postcycle_rest parameter specifies the delay imposed by the system\n        after a LUT table has been output. The delay can be set between 0\n        and 2147483648 sample intervals. The system then outputs the last\n        value in the cycle until the postcycle_rest time has expired.\n    \"\"\"\n    # triggering is not supported by the TPZ device\n    payload = st.pack(\n        \"&lt;HHHLLLLHLH\",\n        Tpz._CHANNEL,\n        mode,\n        cycle_length,\n        num_cycles,\n        delay_time,\n        precycle_rest,\n        postcycle_rest,\n        0,\n        0,\n        0,\n    )\n    await self.send(Message(MGMSG.PZ_SET_OUTPUTLUTPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.set_output_position","title":"<code>set_output_position(position_sw)</code>  <code>async</code>","text":"<p>Set output position of the piezo actuator.</p> <p>This command is only applicable in Closed Loop mode. If called when in Open Loop mode, it is ignored. The position of the actuator is relative to the datum set for the arrangement using the ZeroPosition method.</p> <p>:param position_sw: The output position of the piezo relative to the     zero position. The voltage is set in the range [0; 32767] or     [0; 65535] depending on the unit. This corresponds to 0 to 100% of     the maximum piezo extension.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def set_output_position(self, position_sw: int) -&gt; None:\n    \"\"\"Set output position of the piezo actuator.\n\n    This command is only applicable in Closed Loop mode. If called when in\n    Open Loop mode, it is ignored. The position of the actuator is relative\n    to the datum set for the arrangement using the ZeroPosition method.\n\n    :param position_sw: The output position of the piezo relative to the\n        zero position. The voltage is set in the range [0; 32767] or\n        [0; 65535] depending on the unit. This corresponds to 0 to 100% of\n        the maximum piezo extension.\n    \"\"\"\n    payload = st.pack(\"&lt;HH\", Tpz._CHANNEL, position_sw)\n    await self.send(Message(MGMSG.PZ_SET_OUTPUTPOS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.set_output_volts","title":"<code>set_output_volts(voltage)</code>  <code>async</code>","text":"<p>Set output voltage applied to the piezo actuator.</p> <p>This command is only applicable in Open Loop mode. If called when in Closed Loop mode it is ignored.</p> <p>:param voltage: The output voltage applied to the piezo when operating     in open loop mode. The voltage value must be in range     [0; voltage_limit]. Voltage_limit being set by the     :py:meth:<code>set_tpz_io_settings()&lt;Tpz.set_tpz_io_settings&gt;</code>     method between the three values 75 V, 100 V and 150 V.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def set_output_volts(self, voltage: float) -&gt; None:\n    \"\"\"Set output voltage applied to the piezo actuator.\n\n    This command is only applicable in Open Loop mode. If called when in\n    Closed Loop mode it is ignored.\n\n    :param voltage: The output voltage applied to the piezo when operating\n        in open loop mode. The voltage value must be in range\n        [0; voltage_limit]. Voltage_limit being set by the\n        :py:meth:`set_tpz_io_settings()&lt;Tpz.set_tpz_io_settings&gt;`\n        method between the three values 75 V, 100 V and 150 V.\n    \"\"\"\n    if self.voltage_limit is None:\n        raise ValueError(\"Voltage limit is not set\")\n\n    if voltage &lt; 0 or voltage &gt; self.voltage_limit:\n        raise ValueError(\n            \"Voltage must be in range [0;{}]\".format(self.voltage_limit)\n        )\n    volt = int(voltage * 32767 / self.voltage_limit)\n    payload = st.pack(\"&lt;HH\", Tpz._CHANNEL, volt)\n    await self.send(Message(MGMSG.PZ_SET_OUTPUTVOLTS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.set_pi_constants","title":"<code>set_pi_constants(prop_const, int_const)</code>  <code>async</code>","text":"<p>Set the proportional and integration feedback loop constants.</p> <p>These parameters determine the response characteristics when operating in closed loop mode. The processors within the controller compare the required (demanded) position with the actual position to create an error, which is then passed through a digital PI-type filter. The filtered value is used to develop an output voltage to drive the pizeo.</p> <p>:param prop_const: Value of the proportional term in range [0; 255]. :param int_const: Value of the integral term in range [0; 255].</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def set_pi_constants(self, prop_const: int, int_const: int) -&gt; None:\n    \"\"\"Set the proportional and integration feedback loop constants.\n\n    These parameters determine the response characteristics when operating\n    in closed loop mode.\n    The processors within the controller compare the required (demanded)\n    position with the actual position to create an error, which is then\n    passed through a digital PI-type filter. The filtered value is used to\n    develop an output voltage to drive the pizeo.\n\n    :param prop_const: Value of the proportional term in range [0; 255].\n    :param int_const: Value of the integral term in range [0; 255].\n    \"\"\"\n    payload = st.pack(\"&lt;HHH\", Tpz._CHANNEL, prop_const, int_const)\n    await self.send(Message(MGMSG.PZ_SET_PICONSTS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.set_position_control_mode","title":"<code>set_position_control_mode(control_mode)</code>  <code>async</code>","text":"<p>Set the control loop mode.</p> <p>When in closed-loop mode, position is maintained by a feedback signal from the piezo actuator. This is only possible when using actuators equipped with position sensing.</p> <p>:param control_mode: 0x01 for Open Loop (no feedback).     0x02 for Closed Loop (feedback employed).     0x03 for Open Loop Smooth.     0x04 for Closed Loop Smooth.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def set_position_control_mode(self, control_mode: int) -&gt; None:\n    \"\"\"Set the control loop mode.\n\n    When in closed-loop mode, position is maintained by a feedback signal\n    from the piezo actuator. This is only possible when using actuators\n    equipped with position sensing.\n\n    :param control_mode: 0x01 for Open Loop (no feedback).\n        0x02 for Closed Loop (feedback employed).\n        0x03 for Open Loop Smooth.\n        0x04 for Closed Loop Smooth.\n    \"\"\"\n    await self.send(\n        Message(\n            MGMSG.PZ_SET_POSCONTROLMODE, param1=Tpz._CHANNEL, param2=control_mode\n        )\n    )\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.set_tpz_display_settings","title":"<code>set_tpz_display_settings(intensity)</code>  <code>async</code>","text":"<p>Set the intensity of the LED display on the front of the TPZ unit.</p> <p>:param intensity: The intensity is set as a value from 0 (Off) to 255     (brightest).</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def set_tpz_display_settings(self, intensity: int) -&gt; None:\n    \"\"\"Set the intensity of the LED display on the front of the TPZ unit.\n\n    :param intensity: The intensity is set as a value from 0 (Off) to 255\n        (brightest).\n    \"\"\"\n    payload = st.pack(\"&lt;H\", intensity)\n    await self.send(Message(MGMSG.PZ_SET_TPZ_DISPSETTINGS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.set_tpz_io_settings","title":"<code>set_tpz_io_settings(voltage_limit, hub_analog_input)</code>  <code>async</code>","text":"<p>Set various I/O settings.</p> <p>:param voltage_limit: The piezo actuator connected to the T-Cube has a     specific maximum operating voltage. This parameter sets the maximum     output to the value among the following ones:</p> <pre><code>75 V limit.\n\n100 V limit.\n\n150 V limit.\n</code></pre> <p>:param hub_analog_input: When the T-Cube piezo driver unit is used in     conjunction with the T-Cube Strain Gauge Reader (TSG001) on the     T-Cube Controller Hub (TCH001), a feedback signal can be passed     from the Strain Gauge Reader to the Piezo unit.     High precision closed loop operation is then possible using the     complete range of feedback-equipped piezo actuators.     This parameter is routed to the Piezo unit as follows:</p> <pre><code>0x01: the feedback signals run through all T-Cube bays.\n\n0x02: the feedback signals run between adjacent pairs of T-Cube\nbays (i.e. 1&amp;2, 3&amp;4, 5&amp;6). This setting is useful when several\npairs of Strain Gauge/Piezo Driver cubes are being used on the same\nhub.\n\n0x03: the feedback signals run through the read panel SMA\nconnectors.\n</code></pre> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def set_tpz_io_settings(\n    self, voltage_limit: int, hub_analog_input: int\n) -&gt; None:\n    \"\"\"Set various I/O settings.\n\n    :param voltage_limit: The piezo actuator connected to the T-Cube has a\n        specific maximum operating voltage. This parameter sets the maximum\n        output to the value among the following ones:\n\n        75 V limit.\n\n        100 V limit.\n\n        150 V limit.\n    :param hub_analog_input: When the T-Cube piezo driver unit is used in\n        conjunction with the T-Cube Strain Gauge Reader (TSG001) on the\n        T-Cube Controller Hub (TCH001), a feedback signal can be passed\n        from the Strain Gauge Reader to the Piezo unit.\n        High precision closed loop operation is then possible using the\n        complete range of feedback-equipped piezo actuators.\n        This parameter is routed to the Piezo unit as follows:\n\n        0x01: the feedback signals run through all T-Cube bays.\n\n        0x02: the feedback signals run between adjacent pairs of T-Cube\n        bays (i.e. 1&amp;2, 3&amp;4, 5&amp;6). This setting is useful when several\n        pairs of Strain Gauge/Piezo Driver cubes are being used on the same\n        hub.\n\n        0x03: the feedback signals run through the read panel SMA\n        connectors.\n    \"\"\"\n    self.voltage_limit = voltage_limit\n\n    if self.voltage_limit == 75:\n        voltage_limit = 1\n    elif self.voltage_limit == 100:\n        voltage_limit = 2\n    elif self.voltage_limit == 150:\n        voltage_limit = 3\n    else:\n        raise ValueError(\"voltage_limit must be 75 V, 100 V or 150 V\")\n\n    payload = st.pack(\n        \"&lt;HHHHH\",\n        Tpz._CHANNEL,\n        voltage_limit,\n        hub_analog_input,\n        Tpz._RESERVED,\n        Tpz._RESERVED,\n    )\n    await self.send(Message(MGMSG.PZ_SET_TPZ_IOSETTINGS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.start_lut_output","title":"<code>start_lut_output()</code>  <code>async</code>","text":"<p>Start the voltage waveform (LUT) outputs.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def start_lut_output(self) -&gt; None:\n    \"\"\"Start the voltage waveform (LUT) outputs.\"\"\"\n    await self.send(Message(MGMSG.PZ_START_LUTOUTPUT, param1=Tpz._CHANNEL))\n</code></pre>"},{"location":"sections/cube/tcube/tpz001/#thorlabs_cube.driver.tcube.tpz.Tpz.stop_lut_output","title":"<code>stop_lut_output()</code>  <code>async</code>","text":"<p>Stop the voltage waveform (LUT) outputs.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tpz.py</code> <pre><code>async def stop_lut_output(self) -&gt; None:\n    \"\"\"Stop the voltage waveform (LUT) outputs.\"\"\"\n    await self.send(Message(MGMSG.PZ_STOP_LUTOUTPUT, param1=Tpz._CHANNEL))\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/","title":"TSC001","text":""},{"location":"sections/cube/tcube/tsc001/#controller-description","title":"Controller Description","text":"<p>The TSC001 is a compact single-channel T-Cube controller from Thorlabs designed for precise control of solenoids. It enables smooth and accurate actuation of solenoids, making it ideal for applications requiring controlled switching or force actuation. The TSC001 provides adjustable current settings for solenoid operation and features USB connectivity for computer control via Thorlabs\u2019 Kinesis Software or QuantumION's Thorlabs Cube Repository.</p>"},{"location":"sections/cube/tcube/tsc001/#controller-use-cases","title":"Controller Use-Cases","text":"<ul> <li>TSC001 is commonly used in applications requiring reliable solenoid actuation, such as:<ol> <li>Optomechanical Systems: Switching optical paths or shutters.</li> <li>Laser Systems: Controlling mechanical shutters for beam blocking or modulation.</li> <li>Industrial Automation: Actuating mechanical locks, switches, or small actuators.</li> </ol> </li> </ul>"},{"location":"sections/cube/tcube/tsc001/#peripherals-examples","title":"Peripherals Examples","text":"<ul> <li>Optical Shutters </li> <li>Motorized Flip Mounts </li> </ul>"},{"location":"sections/cube/tcube/tsc001/#api-reference","title":"API Reference","text":"<p>               Bases: <code>_Cube</code></p> <p>TSC001 T-Cube Motor Controller class</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>class Tsc(_Cube):\n    \"\"\"TSC001 T-Cube Motor Controller class\"\"\"\n\n    def __init__(self, serial_dev):\n        super().__init__(serial_dev)\n        self.status_report_counter = 0\n\n    async def handle_message(self, msg) -&gt; None:\n        msg_id = msg.id\n        data = msg.data\n\n        if msg_id == MGMSG.HW_DISCONNECT:\n            raise MsgError(\"Error: Please disconnect the TSC001\")\n        elif msg_id == MGMSG.HW_RESPONSE:\n            raise MsgError(\"Hardware error, please disconnect and reconnect the TSC001\")\n        elif msg_id == MGMSG.HW_RICHRESPONSE:\n            (code,) = st.unpack(\"&lt;H\", data[2:4])\n            raise MsgError(\n                \"Hardware error {}: {}\".format(code, data[4:].decode(encoding=\"ascii\"))\n            )\n        elif (\n            msg_id == MGMSG.MOT_MOVE_COMPLETED\n            or msg_id == MGMSG.MOT_MOVE_STOP\n            or msg_id == MGMSG.MOT_GET_STATUSUPDATE\n        ):\n            if self.status_report_counter == 25:\n                self.status_report_counter = 0\n                await self.send(Message(MGMSG.MOT_MOVE_COMPLETED))\n            else:\n                self.status_report_counter += 1\n            (\n                self.position,\n                self.encoder_count,\n                self.status_bits,\n                self.chan_identity_two,\n                _,\n                _,\n                _,\n            ) = st.unpack(\n                \"&lt;LLLHLLL\",\n                data[2:],\n            )\n\n    async def get_bay_used(self) -&gt; int:\n        \"\"\"Identify which bay is being used by the controller on Thorlabs Hub\n\n        :return: Integer representing the bay being used on the Thorlabs Hub\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.HUB_REQ_BAYUSED, [MGMSG.HUB_GET_BAYUSED], Tsc._CHANNEL\n        )\n\n        return get_msg.param1\n\n    async def set_absolute_position(self, absolute_position: int) -&gt; None:\n        \"\"\"Move the motor to an absolute position.\n\n        :param absolute_position: The absolute position in encoder counts.\n                                E.g., 200,000 counts for 10 mm.\n        \"\"\"\n        payload = st.pack(\"&lt;Hl\", Tsc._CHANNEL, absolute_position)\n\n        await self.send_request(\n            MGMSG.MOT_MOVE_ABSOLUTE,\n            [MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_STOPPED],\n            data=payload,\n        )\n\n    async def move_stop(self, stop_mode: int) -&gt; None:\n        \"\"\"Stop any type of motor move (relative, absolute, homing, or velocity).\n\n        :param stop_mode: The stop mode (1 for immediate stop, 2 for profiled stop).\n        \"\"\"\n        await self.send_request(\n            MGMSG.MOT_MOVE_STOP,\n            [MGMSG.MOT_MOVE_STOPPED],\n            param1=Tsc._CHANNEL,\n            param2=stop_mode,\n        )\n\n    async def set_av_modes(self, mode_bits: int) -&gt; None:\n        \"\"\"Set the LED indicator modes based on the provided mode_bits.\n\n        :param mode_bits: A bitmask indicating which modes to enable:\n                        - 1 (LEDMODE_IDENT): LED flashes when 'Ident' is sent.\n                        - 2 (LEDMODE_LIMITSWITCH): LED flashes when motor reaches limit switch.\n                        - 8 (LEDMODE_MOVING): LED is lit when the motor is moving.\n        \"\"\"\n        payload = st.pack(\"&lt;Hl\", Tsc._CHANNEL, mode_bits)\n        await self.send(Message(MGMSG.MOT_SET_AVMODES, data=payload))\n\n    async def get_av_modes(self) -&gt; int:\n        \"\"\"Get the current LED indicator mode bits set by set_av_modes(self, mode_bits)\n\n        :return: The LED mode bits set\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_AVMODES, [MGMSG.MOT_GET_AVMODES], Tsc._CHANNEL\n        )\n\n        return get_msg.data[2:]\n\n    async def set_button_parameters(\n        self, mode: int, position1: int, position2: int, timeout1: int, timeout2: int\n    ) -&gt; None:\n        \"\"\"Set button parameters for the front panel buttons.\n\n        :param mode: Mode for the buttons (1 for jog, 2 for position mode).\n        :param position1: Position in encoder counts for the top button.\n        :param position2: Position in encoder counts for the bottom button.\n        :param timeout1: Timeout in ms for position1.\n        :param timeout2: Timeout in ms for position2.\n        \"\"\"\n        payload = st.pack(\n            \"&lt;HHllHH\", Tsc._CHANNEL, mode, position1, position2, timeout1, timeout2\n        )\n\n        await self.send(Message(MGMSG.MOT_SET_BUTTONPARAMS, data=payload))\n\n    async def get_button_parameters(self) -&gt; tuple[int, int, int, int, int]:\n        \"\"\"Get the current button parameters.\n\n        :return: A tuple containing (mode, position1, position2, timeout1, timeout2)\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_BUTTONPARAMS, [MGMSG.MOT_GET_BUTTONPARAMS], Tsc._CHANNEL\n        )\n\n        return st.unpack(\"&lt;HllHH\", get_msg.data[2:])\n\n    async def set_eeprom_parameters(self, msg_id: int) -&gt; None:\n        \"\"\"Save the current parameters for the specified message in the EEPROM.\n\n        This function sends a request to the device to save the parameter settings\n        of the specified message to the EEPROM memory, ensuring the settings are\n        retained even after the device is powered off.\n\n        :param msg_id: The message ID of the message containing the parameters\n                       that need to be saved in the EEPROM.\n        \"\"\"\n        payload = st.pack(\"&lt;HH\", Tsc._CHANNEL, msg_id)\n\n        await self.send(Message(MGMSG.MOT_SET_EEPROMPARAMS, data=payload))\n\n    async def get_status_update(self) -&gt; tuple[int, int, int, int]:\n        \"\"\"Returns a status update on the specified motor channel\n\n        This function sends a request to the device to return status updates of\n        position, encoder count, status bits on channel one as well as, for future use,\n        returns channel identity two and its associated data which is garbage right now\n\n        :return: A tuple containing (position, encoder_count, status_bits, chan_identity_two)\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_STATUSUPDATE, [MGMSG.MOT_GET_STATUSUPDATE], Tsc._CHANNEL\n        )\n        (\n            position,\n            encoder_count,\n            status_bits,\n            chan_identity_two,\n            _,\n            _,\n            _,\n        ) = st.unpack(\"&lt;HIIIHIII\", get_msg.data[2:])\n\n        return position, encoder_count, status_bits, chan_identity_two\n\n    async def set_sol_operating_mode(self, operating_mode: int) -&gt; None:\n        \"\"\"Set the solenoid operating mode for the single channel.\n\n        :param operating_mode: The operating mode to set (e.g., 1, 2, etc.).\n        \"\"\"\n        await self.send(Message(MGMSG.MOT_SET_SOL_OPERATINGMODE, param2=operating_mode))\n\n    async def get_sol_operating_mode(self) -&gt; int:\n        \"\"\"Get the current solenoid operating mode for the single channel.\n\n        :return: Operating mode of solenoid represented by an integer\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_SOL_OPERATINGMODE,\n            [MGMSG.MOT_GET_SOL_OPERATINGMODE],\n            param1=Tsc._CHANNEL,\n        )\n\n        return get_msg.param2\n\n    async def set_solenoid_cycle_parameters(\n        self, on_time: int, off_time: int, num_cycles: int\n    ) -&gt; None:\n        \"\"\"Set the solenoid cycle parameters.\n\n        :param on_time: Time (in ms) the solenoid stays on (100ms to 10,000ms).\n        :param off_time: Time (in ms) the solenoid stays off (100ms to 10,000ms).\n        :param num_cycles: Number of open/close cycles (0 for infinite, up to 1,000,000).\n        \"\"\"\n        payload = st.pack(\"&lt;HLLL\", Tsc._CHANNEL, on_time, off_time, num_cycles)\n        await self.send(Message(MGMSG.MOT_SET_SOL_CYCLEPARAMS, data=payload))\n\n    async def get_solenoid_cycle_parameters(self) -&gt; tuple[int, int, int]:\n        \"\"\"Get the current solenoid cycle parameters.\n\n        :return: A tuple containing (on_time, off_time, num_cycles).\n        \"\"\"\n        payload = st.pack(\"&lt;H\", Tsc._CHANNEL)\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_SOL_CYCLEPARAMS, [MGMSG.MOT_GET_SOL_CYCLEPARAMS], data=payload\n        )\n\n        return st.unpack(\"&lt;LLL\", get_msg.data[2:])\n\n    async def set_sol_interlock_mode(self, mode: int) -&gt; None:\n        \"\"\"Set the solenoid interlock mode.\n\n        :param mode: Interlock mode, where:\n                    - 0x01 = SOLENOID_ENABLED (hardware interlock required)\n                    - 0x02 = SOLENOID_DISABLED (hardware interlock not required)\n        \"\"\"\n        await self.send(Message(MGMSG.MOT_SET_SOL_INTERLOCKMODE, param2=mode))\n\n    async def get_sol_interlock_mode(self) -&gt; int:\n        \"\"\"Get the current solenoid interlock mode.\n\n        :return: The interlock mode, where:\n                - 0x01 = SOLENOID_ENABLED (hardware interlock required)\n                - 0x02 = SOLENOID_DISABLED (hardware interlock not required)\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_SOL_INTERLOCKMODE,\n            [MGMSG.MOT_GET_SOL_INTERLOCKMODE],\n            param1=Tsc._CHANNEL,\n        )\n\n        return get_msg.param2\n\n    async def set_sol_state(self, state: int) -&gt; None:\n        \"\"\"Set the solenoid state (ON or OFF).\n\n        :param state: The solenoid state, where:\n                    - 0x01 = SOLENOID_ON (solenoid is active).\n                    - 0x02 = SOLENOID_OFF (solenoid is deactivated).\n        \"\"\"\n        await self.send(\n            Message(MGMSG.MOT_SET_SOL_STATE, param1=Tsc._CHANNEL, param2=state)\n        )\n\n    async def get_sol_state(self) -&gt; int:\n        \"\"\"Get the current solenoid state.\n\n        :return: The solenoid state, where:\n                - 0x01 = SOLENOID_ON (solenoid is active).\n                - 0x02 = SOLENOID_OFF (solenoid is deactivated).\n        \"\"\"\n        get_msg = await self.send_request(\n            MGMSG.MOT_REQ_SOL_STATE, [MGMSG.MOT_GET_SOL_STATE], param1=Tsc._CHANNEL\n        )\n\n        return get_msg.param2\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.get_av_modes","title":"<code>get_av_modes()</code>  <code>async</code>","text":"<p>Get the current LED indicator mode bits set by set_av_modes(self, mode_bits)</p> <p>:return: The LED mode bits set</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def get_av_modes(self) -&gt; int:\n    \"\"\"Get the current LED indicator mode bits set by set_av_modes(self, mode_bits)\n\n    :return: The LED mode bits set\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_AVMODES, [MGMSG.MOT_GET_AVMODES], Tsc._CHANNEL\n    )\n\n    return get_msg.data[2:]\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.get_bay_used","title":"<code>get_bay_used()</code>  <code>async</code>","text":"<p>Identify which bay is being used by the controller on Thorlabs Hub</p> <p>:return: Integer representing the bay being used on the Thorlabs Hub</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def get_bay_used(self) -&gt; int:\n    \"\"\"Identify which bay is being used by the controller on Thorlabs Hub\n\n    :return: Integer representing the bay being used on the Thorlabs Hub\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.HUB_REQ_BAYUSED, [MGMSG.HUB_GET_BAYUSED], Tsc._CHANNEL\n    )\n\n    return get_msg.param1\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.get_button_parameters","title":"<code>get_button_parameters()</code>  <code>async</code>","text":"<p>Get the current button parameters.</p> <p>:return: A tuple containing (mode, position1, position2, timeout1, timeout2)</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def get_button_parameters(self) -&gt; tuple[int, int, int, int, int]:\n    \"\"\"Get the current button parameters.\n\n    :return: A tuple containing (mode, position1, position2, timeout1, timeout2)\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_BUTTONPARAMS, [MGMSG.MOT_GET_BUTTONPARAMS], Tsc._CHANNEL\n    )\n\n    return st.unpack(\"&lt;HllHH\", get_msg.data[2:])\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.get_sol_interlock_mode","title":"<code>get_sol_interlock_mode()</code>  <code>async</code>","text":"<p>Get the current solenoid interlock mode.</p> <p>:return: The interlock mode, where:         - 0x01 = SOLENOID_ENABLED (hardware interlock required)         - 0x02 = SOLENOID_DISABLED (hardware interlock not required)</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def get_sol_interlock_mode(self) -&gt; int:\n    \"\"\"Get the current solenoid interlock mode.\n\n    :return: The interlock mode, where:\n            - 0x01 = SOLENOID_ENABLED (hardware interlock required)\n            - 0x02 = SOLENOID_DISABLED (hardware interlock not required)\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_SOL_INTERLOCKMODE,\n        [MGMSG.MOT_GET_SOL_INTERLOCKMODE],\n        param1=Tsc._CHANNEL,\n    )\n\n    return get_msg.param2\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.get_sol_operating_mode","title":"<code>get_sol_operating_mode()</code>  <code>async</code>","text":"<p>Get the current solenoid operating mode for the single channel.</p> <p>:return: Operating mode of solenoid represented by an integer</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def get_sol_operating_mode(self) -&gt; int:\n    \"\"\"Get the current solenoid operating mode for the single channel.\n\n    :return: Operating mode of solenoid represented by an integer\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_SOL_OPERATINGMODE,\n        [MGMSG.MOT_GET_SOL_OPERATINGMODE],\n        param1=Tsc._CHANNEL,\n    )\n\n    return get_msg.param2\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.get_sol_state","title":"<code>get_sol_state()</code>  <code>async</code>","text":"<p>Get the current solenoid state.</p> <p>:return: The solenoid state, where:         - 0x01 = SOLENOID_ON (solenoid is active).         - 0x02 = SOLENOID_OFF (solenoid is deactivated).</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def get_sol_state(self) -&gt; int:\n    \"\"\"Get the current solenoid state.\n\n    :return: The solenoid state, where:\n            - 0x01 = SOLENOID_ON (solenoid is active).\n            - 0x02 = SOLENOID_OFF (solenoid is deactivated).\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_SOL_STATE, [MGMSG.MOT_GET_SOL_STATE], param1=Tsc._CHANNEL\n    )\n\n    return get_msg.param2\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.get_solenoid_cycle_parameters","title":"<code>get_solenoid_cycle_parameters()</code>  <code>async</code>","text":"<p>Get the current solenoid cycle parameters.</p> <p>:return: A tuple containing (on_time, off_time, num_cycles).</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def get_solenoid_cycle_parameters(self) -&gt; tuple[int, int, int]:\n    \"\"\"Get the current solenoid cycle parameters.\n\n    :return: A tuple containing (on_time, off_time, num_cycles).\n    \"\"\"\n    payload = st.pack(\"&lt;H\", Tsc._CHANNEL)\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_SOL_CYCLEPARAMS, [MGMSG.MOT_GET_SOL_CYCLEPARAMS], data=payload\n    )\n\n    return st.unpack(\"&lt;LLL\", get_msg.data[2:])\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.get_status_update","title":"<code>get_status_update()</code>  <code>async</code>","text":"<p>Returns a status update on the specified motor channel</p> <p>This function sends a request to the device to return status updates of position, encoder count, status bits on channel one as well as, for future use, returns channel identity two and its associated data which is garbage right now</p> <p>:return: A tuple containing (position, encoder_count, status_bits, chan_identity_two)</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def get_status_update(self) -&gt; tuple[int, int, int, int]:\n    \"\"\"Returns a status update on the specified motor channel\n\n    This function sends a request to the device to return status updates of\n    position, encoder count, status bits on channel one as well as, for future use,\n    returns channel identity two and its associated data which is garbage right now\n\n    :return: A tuple containing (position, encoder_count, status_bits, chan_identity_two)\n    \"\"\"\n    get_msg = await self.send_request(\n        MGMSG.MOT_REQ_STATUSUPDATE, [MGMSG.MOT_GET_STATUSUPDATE], Tsc._CHANNEL\n    )\n    (\n        position,\n        encoder_count,\n        status_bits,\n        chan_identity_two,\n        _,\n        _,\n        _,\n    ) = st.unpack(\"&lt;HIIIHIII\", get_msg.data[2:])\n\n    return position, encoder_count, status_bits, chan_identity_two\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.move_stop","title":"<code>move_stop(stop_mode)</code>  <code>async</code>","text":"<p>Stop any type of motor move (relative, absolute, homing, or velocity).</p> <p>:param stop_mode: The stop mode (1 for immediate stop, 2 for profiled stop).</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def move_stop(self, stop_mode: int) -&gt; None:\n    \"\"\"Stop any type of motor move (relative, absolute, homing, or velocity).\n\n    :param stop_mode: The stop mode (1 for immediate stop, 2 for profiled stop).\n    \"\"\"\n    await self.send_request(\n        MGMSG.MOT_MOVE_STOP,\n        [MGMSG.MOT_MOVE_STOPPED],\n        param1=Tsc._CHANNEL,\n        param2=stop_mode,\n    )\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.set_absolute_position","title":"<code>set_absolute_position(absolute_position)</code>  <code>async</code>","text":"<p>Move the motor to an absolute position.</p> <p>:param absolute_position: The absolute position in encoder counts.                         E.g., 200,000 counts for 10 mm.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def set_absolute_position(self, absolute_position: int) -&gt; None:\n    \"\"\"Move the motor to an absolute position.\n\n    :param absolute_position: The absolute position in encoder counts.\n                            E.g., 200,000 counts for 10 mm.\n    \"\"\"\n    payload = st.pack(\"&lt;Hl\", Tsc._CHANNEL, absolute_position)\n\n    await self.send_request(\n        MGMSG.MOT_MOVE_ABSOLUTE,\n        [MGMSG.MOT_MOVE_COMPLETED, MGMSG.MOT_MOVE_STOPPED],\n        data=payload,\n    )\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.set_av_modes","title":"<code>set_av_modes(mode_bits)</code>  <code>async</code>","text":"<p>Set the LED indicator modes based on the provided mode_bits.</p> <p>:param mode_bits: A bitmask indicating which modes to enable:                 - 1 (LEDMODE_IDENT): LED flashes when 'Ident' is sent.                 - 2 (LEDMODE_LIMITSWITCH): LED flashes when motor reaches limit switch.                 - 8 (LEDMODE_MOVING): LED is lit when the motor is moving.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def set_av_modes(self, mode_bits: int) -&gt; None:\n    \"\"\"Set the LED indicator modes based on the provided mode_bits.\n\n    :param mode_bits: A bitmask indicating which modes to enable:\n                    - 1 (LEDMODE_IDENT): LED flashes when 'Ident' is sent.\n                    - 2 (LEDMODE_LIMITSWITCH): LED flashes when motor reaches limit switch.\n                    - 8 (LEDMODE_MOVING): LED is lit when the motor is moving.\n    \"\"\"\n    payload = st.pack(\"&lt;Hl\", Tsc._CHANNEL, mode_bits)\n    await self.send(Message(MGMSG.MOT_SET_AVMODES, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.set_button_parameters","title":"<code>set_button_parameters(mode, position1, position2, timeout1, timeout2)</code>  <code>async</code>","text":"<p>Set button parameters for the front panel buttons.</p> <p>:param mode: Mode for the buttons (1 for jog, 2 for position mode). :param position1: Position in encoder counts for the top button. :param position2: Position in encoder counts for the bottom button. :param timeout1: Timeout in ms for position1. :param timeout2: Timeout in ms for position2.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def set_button_parameters(\n    self, mode: int, position1: int, position2: int, timeout1: int, timeout2: int\n) -&gt; None:\n    \"\"\"Set button parameters for the front panel buttons.\n\n    :param mode: Mode for the buttons (1 for jog, 2 for position mode).\n    :param position1: Position in encoder counts for the top button.\n    :param position2: Position in encoder counts for the bottom button.\n    :param timeout1: Timeout in ms for position1.\n    :param timeout2: Timeout in ms for position2.\n    \"\"\"\n    payload = st.pack(\n        \"&lt;HHllHH\", Tsc._CHANNEL, mode, position1, position2, timeout1, timeout2\n    )\n\n    await self.send(Message(MGMSG.MOT_SET_BUTTONPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.set_eeprom_parameters","title":"<code>set_eeprom_parameters(msg_id)</code>  <code>async</code>","text":"<p>Save the current parameters for the specified message in the EEPROM.</p> <p>This function sends a request to the device to save the parameter settings of the specified message to the EEPROM memory, ensuring the settings are retained even after the device is powered off.</p> <p>:param msg_id: The message ID of the message containing the parameters                that need to be saved in the EEPROM.</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def set_eeprom_parameters(self, msg_id: int) -&gt; None:\n    \"\"\"Save the current parameters for the specified message in the EEPROM.\n\n    This function sends a request to the device to save the parameter settings\n    of the specified message to the EEPROM memory, ensuring the settings are\n    retained even after the device is powered off.\n\n    :param msg_id: The message ID of the message containing the parameters\n                   that need to be saved in the EEPROM.\n    \"\"\"\n    payload = st.pack(\"&lt;HH\", Tsc._CHANNEL, msg_id)\n\n    await self.send(Message(MGMSG.MOT_SET_EEPROMPARAMS, data=payload))\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.set_sol_interlock_mode","title":"<code>set_sol_interlock_mode(mode)</code>  <code>async</code>","text":"<p>Set the solenoid interlock mode.</p> <p>:param mode: Interlock mode, where:             - 0x01 = SOLENOID_ENABLED (hardware interlock required)             - 0x02 = SOLENOID_DISABLED (hardware interlock not required)</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def set_sol_interlock_mode(self, mode: int) -&gt; None:\n    \"\"\"Set the solenoid interlock mode.\n\n    :param mode: Interlock mode, where:\n                - 0x01 = SOLENOID_ENABLED (hardware interlock required)\n                - 0x02 = SOLENOID_DISABLED (hardware interlock not required)\n    \"\"\"\n    await self.send(Message(MGMSG.MOT_SET_SOL_INTERLOCKMODE, param2=mode))\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.set_sol_operating_mode","title":"<code>set_sol_operating_mode(operating_mode)</code>  <code>async</code>","text":"<p>Set the solenoid operating mode for the single channel.</p> <p>:param operating_mode: The operating mode to set (e.g., 1, 2, etc.).</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def set_sol_operating_mode(self, operating_mode: int) -&gt; None:\n    \"\"\"Set the solenoid operating mode for the single channel.\n\n    :param operating_mode: The operating mode to set (e.g., 1, 2, etc.).\n    \"\"\"\n    await self.send(Message(MGMSG.MOT_SET_SOL_OPERATINGMODE, param2=operating_mode))\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.set_sol_state","title":"<code>set_sol_state(state)</code>  <code>async</code>","text":"<p>Set the solenoid state (ON or OFF).</p> <p>:param state: The solenoid state, where:             - 0x01 = SOLENOID_ON (solenoid is active).             - 0x02 = SOLENOID_OFF (solenoid is deactivated).</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def set_sol_state(self, state: int) -&gt; None:\n    \"\"\"Set the solenoid state (ON or OFF).\n\n    :param state: The solenoid state, where:\n                - 0x01 = SOLENOID_ON (solenoid is active).\n                - 0x02 = SOLENOID_OFF (solenoid is deactivated).\n    \"\"\"\n    await self.send(\n        Message(MGMSG.MOT_SET_SOL_STATE, param1=Tsc._CHANNEL, param2=state)\n    )\n</code></pre>"},{"location":"sections/cube/tcube/tsc001/#thorlabs_cube.driver.tcube.tsc.Tsc.set_solenoid_cycle_parameters","title":"<code>set_solenoid_cycle_parameters(on_time, off_time, num_cycles)</code>  <code>async</code>","text":"<p>Set the solenoid cycle parameters.</p> <p>:param on_time: Time (in ms) the solenoid stays on (100ms to 10,000ms). :param off_time: Time (in ms) the solenoid stays off (100ms to 10,000ms). :param num_cycles: Number of open/close cycles (0 for infinite, up to 1,000,000).</p> Source code in <code>venv/lib/python3.9/site-packages/thorlabs_cube/driver/tcube/tsc.py</code> <pre><code>async def set_solenoid_cycle_parameters(\n    self, on_time: int, off_time: int, num_cycles: int\n) -&gt; None:\n    \"\"\"Set the solenoid cycle parameters.\n\n    :param on_time: Time (in ms) the solenoid stays on (100ms to 10,000ms).\n    :param off_time: Time (in ms) the solenoid stays off (100ms to 10,000ms).\n    :param num_cycles: Number of open/close cycles (0 for infinite, up to 1,000,000).\n    \"\"\"\n    payload = st.pack(\"&lt;HLLL\", Tsc._CHANNEL, on_time, off_time, num_cycles)\n    await self.send(Message(MGMSG.MOT_SET_SOL_CYCLEPARAMS, data=payload))\n</code></pre>"},{"location":"sections/tutorial/tutorials/","title":"Tutorials","text":"<p>The following tutorials will outline key examples of how to interact with this repository</p>"},{"location":"sections/tutorial/tutorials/#1-sipyco-rpc-control","title":"1.  SiPyCo RPC Control \ud83d\udd17","text":"<ul> <li>This tutorial will allow users to start their Thorlabs application in a local server or Docker container, and interact with it over SiPyCo's Remote Procedure Call (RPC)</li> </ul>"},{"location":"sections/tutorial/tutorials/#2-artiq-control","title":"2.  ARTIQ Control \ud83d\udd17","text":"<ul> <li>This tutorial will allow users to start their Thorlabs application in a local server with the ARTIQ control file, and interact with it using ARTIQ's RPC Tool</li> </ul>"},{"location":"sections/tutorial/examples/artiq/","title":"Adding Thorlabs T/K Cube Devices to ARTIQ Device Database and Interacting via RPC","text":"<p>Adding Thorlabs T/K-Cube devices to the ARTIQ device database and interacting with them using <code>artiq_rpctool</code> involves the following steps.</p>"},{"location":"sections/tutorial/examples/artiq/#step-1-set-up-your-device-and-controller","title":"Step 1: Set Up Your Device and Controller","text":"<p>Before configuring the device database:</p> <ol> <li>Connect USB First, Then Power Up: Always connect the USB cable before powering up the device to prevent it from entering a problematic state.</li> <li>Start the Controller: Run the appropriate controller for your Thorlabs Cube device using the <code>aqctl_thorlabs_cube</code> command. Example for different devices:</li> </ol>"},{"location":"sections/tutorial/examples/artiq/#tpz001-t-cube-piezo-controller","title":"TPZ001 (T-Cube Piezo Controller)","text":"<pre><code>aqctl_thorlabs_cube -P tpz001 -d /dev/ttyUSBx\n</code></pre> <p>Notes: - On Windows, the <code>-d</code> argument will be of the form <code>COMx</code>. - You can specify the device using its Vendor/Product ID and USB Serial Number with the <code>hwgrep</code> URL format:   <code>bash   -d \"hwgrep://&lt;VID&gt;:&lt;PID&gt; SNR=&lt;serial_number&gt;\"</code></p>"},{"location":"sections/tutorial/examples/artiq/#step-2-add-device-to-the-artiq-device-database","title":"Step 2: Add Device to the ARTIQ Device Database","text":"<p>Modify the <code>device_db.py</code> file to include an entry for the Thorlabs device. For example:</p> <pre><code>device_db = {\n    # Core device configuration\n\n    \"core\": {\n        \"type\": \"local\",\n        \"module\": \"artiq.coredevice.core\",\n        \"class\": \"Core\",\n        \"arguments\": {\n            \"host\": \"192.168.1.100\",  # Replace with your host device's IP\n        }\n    },\n\n    # Thorlabs TPZ001 Controller\n\n    \"thorlabs_tpz001\": {\n        \"type\": \"controller\",\n        \"host\": \"localhost\",         # Replace with the IP of the controller\n        \"port\": 3255,                # Port where the Thorlabs controller listens\n        \"target\": \"tpz001\",          # Controller target name\n        \"command\": \"aqctl_thorlabs_cube -P tpz001 -d /dev/ttyUSB0\",\n    }\n}\n</code></pre>"},{"location":"sections/tutorial/examples/artiq/#explanation","title":"Explanation:","text":"<ul> <li><code>type</code>: Set to <code>controller</code> for remote (non-real-time) devices.</li> <li><code>host</code>: Set to <code>localhost</code> if the controller is running on the same machine or the IP of the machine hosting the controller.</li> <li><code>port</code>: TCP port the controller is listening on (<code>3255</code> in this example).</li> <li><code>target</code>: The target name (use <code>artiq_rpctool ::1 &lt;port&gt; list-targets</code> to confirm).</li> <li><code>command</code>: Command to start the controller.</li> </ul>"},{"location":"sections/tutorial/examples/artiq/#step-3-interact-with-the-device-using-artiq_rpctool","title":"Step 3: Interact with the Device Using <code>artiq_rpctool</code>","text":"<p>You can send commands to the Thorlabs device via the <code>artiq_rpctool</code> utility. Below are examples for different devices.</p>"},{"location":"sections/tutorial/examples/artiq/#tpz001-t-cube-piezo-controller_1","title":"TPZ001 (T-Cube Piezo Controller)","text":"<pre><code>artiq_rpctool ::1 3255 list-targets\nartiq_rpctool ::1 3255 call set_output_volts 15   # Set output voltage to 15 V\nartiq_rpctool ::1 3255 call get_output_volts      # Read back output voltage\nartiq_rpctool ::1 3255 call set_tpz_io_settings 150 1 # Set max output voltage to 150 V\nartiq_rpctool ::1 3255 call close                 # Close the device\n</code></pre>"},{"location":"sections/tutorial/examples/artiq/#step-4-verify-and-debug-with-artiq_rpctool","title":"Step 4: Verify and Debug with <code>artiq_rpctool</code>","text":"<ol> <li>List Targets:</li> </ol> <pre><code>$ artiq_rpctool ::1 3255 list-targets\n</code></pre> <p>Output example:    <code>Target(s):   kdc101</code></p> <ol> <li>List Available Methods:</li> </ol> <pre><code>$ artiq_rpctool ::1 3255 list-methods\n</code></pre> <ol> <li>Call a Method:</li> </ol> <pre><code>$ artiq_rpctool ::1 3255 call move_relative 10000\n</code></pre>"},{"location":"sections/tutorial/examples/artiq/#notes","title":"Notes","text":"<ol> <li> <p>Persistent Device Database:    After modifying <code>device_db.py</code>, update the ARTIQ master:    <code>bash    artiq_client scan-devices</code></p> </li> <li> <p>Controller State:    Ensure the controller is running and listening on the configured port (<code>aqctl_thorlabs_cube</code> should still be active).</p> </li> <li> <p>Troubleshooting:</p> </li> <li>If the device is unresponsive, ensure USB is connected before power-up.</li> <li>Use <code>--help</code> with <code>aqctl_thorlabs_cube</code> for detailed command-line options.</li> </ol>"},{"location":"sections/tutorial/examples/docker/","title":"Docker Container","text":"<p>As a user, you may want to spin up a Docker container to launch your Thorlabs application and interact with it; follow the steps below to use containers to host Thorlabs controllers</p>"},{"location":"sections/tutorial/examples/docker/#step-1-describe-a-container-within-composeyml","title":"Step 1. Describe a container within compose.yml","text":"<pre><code>container_name: ksc101\n        restart: always\n        ports:\n            - 3255:3255\n        devices:\n            - /dev/kdc101:/dev/ttyUSB0\n        networks:\n            - thorlabs_cube\n        build:\n            context: ./\n            dockerfile: ./Dockerfile\n        # to run in simulation mode, include \"--simulation\"\n        # in the entrypoint command after port number\n        entrypoint: [aqctl_thorlabs_cube]\n        command: [-p, '3255', -P, ksc101, -d, /dev/ttyUSB0, --bind, '*']\n</code></pre>"},{"location":"sections/tutorial/examples/docker/#explanation-of-key-elements","title":"Explanation of Key Elements:","text":"<ul> <li> <p><code>container_name</code>   The name given to the container, used to identify which containers are spun up.   In this example, the container is named <code>ksc101</code>.</p> </li> <li> <p><code>restart</code>   Specifies the restart policy for the container. <code>always</code> ensures the container restarts automatically if it stops.</p> </li> <li> <p><code>ports</code>:   Maps port <code>3255</code> on the host to port <code>3255</code> inside the container. Format <code>&lt;host_port&gt;:&lt;container_port&gt;</code></p> </li> <li> <p><code>devices</code>   Maps the hardware device <code>/dev/ksc101</code> on the host to <code>/dev/ttyUSB0</code> inside the container. This enables the container to access the hardware directly.</p> </li> <li> <p><code>networks</code>   Indicates the custom network <code>thorlabs_cube</code> to which the container belongs. This allows communication between containers in the same network.</p> </li> <li> <p><code>build</code>   Specifies how the container image should be built. <code>context</code> points to the build directory (here, the current directory <code>./</code>). <code>dockerfile</code> path to the Dockerfile used to build the image.</p> </li> <li> <p><code>entrypoint</code>   Specifies the executable that runs when the container starts. In this case, it is <code>aqctl_thorlabs_cube</code>.</p> </li> <li> <p><code>command</code>   Specifies additional arguments passed to the <code>entrypoint</code>.</p> <ul> <li><code>-p '3255'</code>: Specifies the port.</li> <li><code>-P ksc101</code>: Specifies the device protocol.</li> <li><code>-d /dev/ttyUSB0</code>: Points to the device.</li> <li><code>--bind '*'</code>: Allows binding to all network interfaces.</li> </ul> </li> </ul>"},{"location":"sections/tutorial/examples/docker/#step-2-build-and-launch-the-thorlabs-application-with-docker-compose","title":"Step 2. Build and launch the Thorlabs application with Docker Compose:","text":"<pre><code>$ docker compose build\n$ docker compose up -d\n</code></pre> <ul> <li>Uses the information given within the compose.yml file to build and spin up the Thorlabs application in a container</li> </ul>"},{"location":"sections/tutorial/examples/local/","title":"Starting a Local Server for Thorlabs Application","text":"<p>To start a local server to run the Thorlabs application using the <code>aqctl_thorlabs_cube.py</code> module, you need the following components:</p> <ol> <li>Module: The <code>aqctl_thorlabs_cube.py</code> file must be targeted as the module.</li> <li>Port: Specify a port for the server to listen on.</li> <li>Product Identifier: Provide a valid product identifier (e.g., <code>ksc101</code>).</li> <li>Device Address: Indicate the address where the hardware is connected (e.g., <code>/dev/ttyUSB0</code>).</li> </ol>"},{"location":"sections/tutorial/examples/local/#command-syntax","title":"Command Syntax","text":"<p>The command follows this structure:</p> <pre><code>python3 -m thorlabs_cube.aqctl_thorlabs_cube -p [port] --product [product_identifier] --device [device_address]\n</code></pre>"},{"location":"sections/tutorial/examples/local/#example-command","title":"Example Command","text":"<p>Here is an example of starting the server:</p> <pre><code>python3 -m thorlabs_cube.aqctl_thorlabs_cube -p 3257 --product ksc101 --device /dev/ttyUSB0\n</code></pre> <ul> <li><code>-m thorlabs_cube.aqctl_thorlabs_cube</code>: Specifies the module to run.</li> <li><code>-p 3257</code>: The server listens on port <code>3257</code>.</li> <li><code>--product ksc101</code>: The product identifier for the Thorlabs device (e.g., <code>ksc101</code> for a stepper motor controller).</li> <li><code>--device /dev/ttyUSB0</code>: The system address where the hardware is connected (e.g., <code>/dev/ttyUSB0</code> for Linux).</li> </ul>"},{"location":"sections/tutorial/examples/local/#key-points","title":"Key Points","text":"<ol> <li>Virtual Environment: Ensure you activate your Python virtual environment if required before running the command.    <code>bash    source venv/bin/activate</code></li> <li>Port Availability: Make sure the specified port (e.g., <code>3257</code>) is available and not used by another application.</li> <li>Device Connection: Verify the hardware is connected and accessible via the specified address (e.g., <code>/dev/ttyUSB0</code>).</li> </ol>"},{"location":"sections/tutorial/examples/local/#supported-device-drivers","title":"Supported Device Drivers","text":"<p>The following are the currently supported device drivers. These are the strings to use with the <code>--product</code> flag:</p> <ul> <li><code>tdc001</code> (T-Cube DC Servo Driver)</li> <li><code>kdc101</code> (K-Cube DC Servo Motor Driver)</li> <li><code>tpa101</code> (T-Cube Piezo Actuator Driver)</li> <li><code>kpa101</code> (K-Cube Piezo Actuator Driver)</li> <li><code>tpz001</code> (T-Cube Piezo Controller)</li> <li><code>kpz101</code> (K-Cube Piezo Controller)</li> <li><code>tsc001</code> (T-Cube Stepper Controller)</li> <li><code>ksc101</code> (K-Cube Stepper Controller)</li> </ul> <p>With this setup, the local server should start successfully, allowing you to communicate with the Thorlabs device using SiPyCo's RPC or ARTIQ.</p>"},{"location":"sections/tutorial/examples/sipyco/","title":"Using SiPyCo's RPC Tool with Thorlabs Controllers","text":"<p>This document provides an overview of using SiPyCo's RPC tool (<code>sipyco_rpctool</code>) to communicate with Thorlabs controllers. SiPyCo enables seamless interaction with devices through remote procedure calls (RPC). Below is a step-by-step guide and example commands for effectively using the tool.</p>"},{"location":"sections/tutorial/examples/sipyco/#prerequisites","title":"Prerequisites","text":"<p>Install SiPyCo: Ensure that SiPyCo is installed within your venv:</p> <pre><code>$ pip install git+https://github.com/m-labs/sipyco.git\n</code></pre> <p>Running the Device Server: Start the server that wraps the Thorlabs device driver using either Docker or locally run server</p>"},{"location":"sections/tutorial/examples/sipyco/#1-docker-container-server","title":"1.  Docker Container Server \ud83d\udd17","text":""},{"location":"sections/tutorial/examples/sipyco/#2-local-server","title":"2.  Local Server \ud83d\udd17","text":"<p>Device Connectivity: Ensure the Thorlabs device is properly connected to your system, and its driver is functioning.</p>"},{"location":"sections/tutorial/examples/sipyco/#commands-overview","title":"Commands Overview","text":""},{"location":"sections/tutorial/examples/sipyco/#1-list-targets","title":"1. List Targets","text":"<p>To view the available targets (endpoints) exposed by the Thorlabs driver implementation, use the <code>list-targets</code> command:</p> <pre><code>sipyco_rpctool [localhost or IP address] [port] list-targets\n</code></pre>"},{"location":"sections/tutorial/examples/sipyco/#example","title":"Example:","text":"<pre><code>sipyco_rpctool localhost 5000 list-targets\n</code></pre> <p>This command will return a list of all the exposed targets that can be called via RPC.</p>"},{"location":"sections/tutorial/examples/sipyco/#2-list-methods","title":"2. List Methods","text":"<p>To view the available methods provided by a specific target, use the <code>list-methods</code> command:</p> <pre><code>sipyco_rpctool [localhost or IP address] [port] list-methods\n</code></pre>"},{"location":"sections/tutorial/examples/sipyco/#example_1","title":"Example:","text":"<pre><code>sipyco_rpctool localhost 5000 list-methods\n</code></pre> <p>This command outputs all methods exposed by the server, detailing the API functions supported by the Thorlabs device driver.</p>"},{"location":"sections/tutorial/examples/sipyco/#3-call-methods","title":"3. Call Methods","text":"<p>To call a specific API function exposed by the Thorlabs device driver, use the <code>call</code> command. The syntax is:</p> <pre><code>sipyco_rpctool [localhost or IP address] [port] call [method_name] [arguments]\n</code></pre>"},{"location":"sections/tutorial/examples/sipyco/#example_2","title":"Example:","text":"<p>Calling a method <code>move_to_position</code> with an argument <code>100</code>:</p> <pre><code>sipyco_rpctool localhost 5000 call move_to_position 100\n</code></pre> <p>The output will display the result of the function call.</p>"},{"location":"sections/tutorial/examples/sipyco/#workflow-example","title":"Workflow Example","text":"<ol> <li>Start by listing the available targets:</li> </ol> <pre><code>$ sipyco_rpctool localhost 5000 list-targets\n</code></pre> <ol> <li>Select a target and view its methods:</li> </ol> <pre><code>$ sipyco_rpctool localhost 5000 list-methods\n</code></pre> <ol> <li>Call a specific method with the required arguments:</li> </ol> <pre><code>$ sipyco_rpctool localhost 5000 call move_to_position 150\n</code></pre>"},{"location":"sections/tutorial/examples/sipyco/#notes","title":"Notes","text":"<ul> <li>Error Handling: If the command fails, check:<ul> <li>The device server is running and listening on the specified IP and port.</li> <li>The Thorlabs device is connected and properly initialized.</li> <li>The correct target and method names are used.</li> </ul> </li> </ul> <p>This approach simplifies interaction with Thorlabs devices using SiPyCo\u2019s RPC mechanism, making it ideal for automation and testing setups.</p>"}]}
